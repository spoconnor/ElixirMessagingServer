// Generated by ScalaBuff, the Scala Protocol Buffers compiler. DO NOT EDIT!
// source: CommsMessages.proto

package CommsMessages

object MsgType extends net.sandrogrzicic.scalabuff.Enum {
	sealed trait EnumVal extends Value
	val _UNINITIALIZED = new EnumVal { val name = "UNINITIALIZED ENUM VALUE"; val id = -1 }

	val eResponse = new EnumVal { val name = "eResponse"; val id = 1 }
	val ePing = new EnumVal { val name = "ePing"; val id = 2 }
	val ePong = new EnumVal { val name = "ePong"; val id = 3 }
	val eNewUser = new EnumVal { val name = "eNewUser"; val id = 4 }
	val eLogin = new EnumVal { val name = "eLogin"; val id = 5 }
	val eSay = new EnumVal { val name = "eSay"; val id = 6 }
	val eMapRequest = new EnumVal { val name = "eMapRequest"; val id = 7 }
	val eMapIgnore = new EnumVal { val name = "eMapIgnore"; val id = 8 }
	val eMap = new EnumVal { val name = "eMap"; val id = 9 }
	val eMapUpdate = new EnumVal { val name = "eMapUpdate"; val id = 10 }
	val eMapCharacterUpdate = new EnumVal { val name = "eMapCharacterUpdate"; val id = 11 }
	val eQueryServer = new EnumVal { val name = "eQueryServer"; val id = 12 }
	val eQueryServerResponse = new EnumVal { val name = "eQueryServerResponse"; val id = 13 }

	val eResponse_VALUE = 1
	val ePing_VALUE = 2
	val ePong_VALUE = 3
	val eNewUser_VALUE = 4
	val eLogin_VALUE = 5
	val eSay_VALUE = 6
	val eMapRequest_VALUE = 7
	val eMapIgnore_VALUE = 8
	val eMap_VALUE = 9
	val eMapUpdate_VALUE = 10
	val eMapCharacterUpdate_VALUE = 11
	val eQueryServer_VALUE = 12
	val eQueryServerResponse_VALUE = 13

	def valueOf(id: Int) = id match {
		case 1 => eResponse
		case 2 => ePing
		case 3 => ePong
		case 4 => eNewUser
		case 5 => eLogin
		case 6 => eSay
		case 7 => eMapRequest
		case 8 => eMapIgnore
		case 9 => eMap
		case 10 => eMapUpdate
		case 11 => eMapCharacterUpdate
		case 12 => eQueryServer
		case 13 => eQueryServerResponse
		case _default => throw new net.sandrogrzicic.scalabuff.UnknownEnumException(_default)
	}
	val internalGetValueMap = new com.google.protobuf.Internal.EnumLiteMap[EnumVal] {
		def findValueByNumber(id: Int): EnumVal = valueOf(id)
	}
}
final case class Message (
	`msgtype`: Int = 0,
	`from`: String = "",
	`dest`: String = "",
	`response`: Option[Response] = None,
	`ping`: Option[Ping] = None,
	`pong`: Option[Pong] = None,
	`newUser`: Option[NewUser] = None,
	`login`: Option[Login] = None,
	`say`: Option[Say] = None,
	`mapRequest`: Option[MapRequest] = None,
	`mapIgnore`: Option[MapIgnore] = None,
	`map`: Option[Map] = None,
	`mapUpdate`: Option[MapUpdate] = None,
	`mapCharacterUpdate`: Option[MapCharacterUpdate] = None,
	`queryServer`: Option[QueryServer] = None,
	`queryServerResponse`: Option[QueryServerResponse] = None
) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[Message]
	with net.sandrogrzicic.scalabuff.Parser[Message] {

	def setResponse(_f: Response) = copy(`response` = Some(_f))
	def setPing(_f: Ping) = copy(`ping` = Some(_f))
	def setPong(_f: Pong) = copy(`pong` = Some(_f))
	def setNewUser(_f: NewUser) = copy(`newUser` = Some(_f))
	def setLogin(_f: Login) = copy(`login` = Some(_f))
	def setSay(_f: Say) = copy(`say` = Some(_f))
	def setMapRequest(_f: MapRequest) = copy(`mapRequest` = Some(_f))
	def setMapIgnore(_f: MapIgnore) = copy(`mapIgnore` = Some(_f))
	def setMap(_f: Map) = copy(`map` = Some(_f))
	def setMapUpdate(_f: MapUpdate) = copy(`mapUpdate` = Some(_f))
	def setMapCharacterUpdate(_f: MapCharacterUpdate) = copy(`mapCharacterUpdate` = Some(_f))
	def setQueryServer(_f: QueryServer) = copy(`queryServer` = Some(_f))
	def setQueryServerResponse(_f: QueryServerResponse) = copy(`queryServerResponse` = Some(_f))

	def clearResponse = copy(`response` = None)
	def clearPing = copy(`ping` = None)
	def clearPong = copy(`pong` = None)
	def clearNewUser = copy(`newUser` = None)
	def clearLogin = copy(`login` = None)
	def clearSay = copy(`say` = None)
	def clearMapRequest = copy(`mapRequest` = None)
	def clearMapIgnore = copy(`mapIgnore` = None)
	def clearMap = copy(`map` = None)
	def clearMapUpdate = copy(`mapUpdate` = None)
	def clearMapCharacterUpdate = copy(`mapCharacterUpdate` = None)
	def clearQueryServer = copy(`queryServer` = None)
	def clearQueryServerResponse = copy(`queryServerResponse` = None)

	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		output.writeInt32(1, `msgtype`)
		output.writeString(2, `from`)
		output.writeString(3, `dest`)
		if (`response`.isDefined) output.writeMessage(4, `response`.get)
		if (`ping`.isDefined) output.writeMessage(5, `ping`.get)
		if (`pong`.isDefined) output.writeMessage(6, `pong`.get)
		if (`newUser`.isDefined) output.writeMessage(7, `newUser`.get)
		if (`login`.isDefined) output.writeMessage(8, `login`.get)
		if (`say`.isDefined) output.writeMessage(9, `say`.get)
		if (`mapRequest`.isDefined) output.writeMessage(10, `mapRequest`.get)
		if (`mapIgnore`.isDefined) output.writeMessage(11, `mapIgnore`.get)
		if (`map`.isDefined) output.writeMessage(12, `map`.get)
		if (`mapUpdate`.isDefined) output.writeMessage(13, `mapUpdate`.get)
		if (`mapCharacterUpdate`.isDefined) output.writeMessage(14, `mapCharacterUpdate`.get)
		if (`queryServer`.isDefined) output.writeMessage(15, `queryServer`.get)
		if (`queryServerResponse`.isDefined) output.writeMessage(16, `queryServerResponse`.get)
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0
		__size += computeInt32Size(1, `msgtype`)
		__size += computeStringSize(2, `from`)
		__size += computeStringSize(3, `dest`)
		if (`response`.isDefined) __size += computeMessageSize(4, `response`.get)
		if (`ping`.isDefined) __size += computeMessageSize(5, `ping`.get)
		if (`pong`.isDefined) __size += computeMessageSize(6, `pong`.get)
		if (`newUser`.isDefined) __size += computeMessageSize(7, `newUser`.get)
		if (`login`.isDefined) __size += computeMessageSize(8, `login`.get)
		if (`say`.isDefined) __size += computeMessageSize(9, `say`.get)
		if (`mapRequest`.isDefined) __size += computeMessageSize(10, `mapRequest`.get)
		if (`mapIgnore`.isDefined) __size += computeMessageSize(11, `mapIgnore`.get)
		if (`map`.isDefined) __size += computeMessageSize(12, `map`.get)
		if (`mapUpdate`.isDefined) __size += computeMessageSize(13, `mapUpdate`.get)
		if (`mapCharacterUpdate`.isDefined) __size += computeMessageSize(14, `mapCharacterUpdate`.get)
		if (`queryServer`.isDefined) __size += computeMessageSize(15, `queryServer`.get)
		if (`queryServerResponse`.isDefined) __size += computeMessageSize(16, `queryServerResponse`.get)

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): Message = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __msgtype: Int = 0
		var __from: String = ""
		var __dest: String = ""
		var __response: Option[Response] = `response`
		var __ping: Option[Ping] = `ping`
		var __pong: Option[Pong] = `pong`
		var __newUser: Option[NewUser] = `newUser`
		var __login: Option[Login] = `login`
		var __say: Option[Say] = `say`
		var __mapRequest: Option[MapRequest] = `mapRequest`
		var __mapIgnore: Option[MapIgnore] = `mapIgnore`
		var __map: Option[Map] = `map`
		var __mapUpdate: Option[MapUpdate] = `mapUpdate`
		var __mapCharacterUpdate: Option[MapCharacterUpdate] = `mapCharacterUpdate`
		var __queryServer: Option[QueryServer] = `queryServer`
		var __queryServerResponse: Option[QueryServerResponse] = `queryServerResponse`

		def __newMerged = Message(
			__msgtype,
			__from,
			__dest,
			__response,
			__ping,
			__pong,
			__newUser,
			__login,
			__say,
			__mapRequest,
			__mapIgnore,
			__map,
			__mapUpdate,
			__mapCharacterUpdate,
			__queryServer,
			__queryServerResponse
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 8 => __msgtype = in.readInt32()
			case 18 => __from = in.readString()
			case 26 => __dest = in.readString()
			case 34 => __response = Some(readMessage[Response](in, __response.orElse({
				__response = Response.defaultInstance
				__response
			}).get, _emptyRegistry))
			case 42 => __ping = Some(readMessage[Ping](in, __ping.orElse({
				__ping = Ping.defaultInstance
				__ping
			}).get, _emptyRegistry))
			case 50 => __pong = Some(readMessage[Pong](in, __pong.orElse({
				__pong = Pong.defaultInstance
				__pong
			}).get, _emptyRegistry))
			case 58 => __newUser = Some(readMessage[NewUser](in, __newUser.orElse({
				__newUser = NewUser.defaultInstance
				__newUser
			}).get, _emptyRegistry))
			case 66 => __login = Some(readMessage[Login](in, __login.orElse({
				__login = Login.defaultInstance
				__login
			}).get, _emptyRegistry))
			case 74 => __say = Some(readMessage[Say](in, __say.orElse({
				__say = Say.defaultInstance
				__say
			}).get, _emptyRegistry))
			case 82 => __mapRequest = Some(readMessage[MapRequest](in, __mapRequest.orElse({
				__mapRequest = MapRequest.defaultInstance
				__mapRequest
			}).get, _emptyRegistry))
			case 90 => __mapIgnore = Some(readMessage[MapIgnore](in, __mapIgnore.orElse({
				__mapIgnore = MapIgnore.defaultInstance
				__mapIgnore
			}).get, _emptyRegistry))
			case 98 => __map = Some(readMessage[Map](in, __map.orElse({
				__map = Map.defaultInstance
				__map
			}).get, _emptyRegistry))
			case 106 => __mapUpdate = Some(readMessage[MapUpdate](in, __mapUpdate.orElse({
				__mapUpdate = MapUpdate.defaultInstance
				__mapUpdate
			}).get, _emptyRegistry))
			case 114 => __mapCharacterUpdate = Some(readMessage[MapCharacterUpdate](in, __mapCharacterUpdate.orElse({
				__mapCharacterUpdate = MapCharacterUpdate.defaultInstance
				__mapCharacterUpdate
			}).get, _emptyRegistry))
			case 122 => __queryServer = Some(readMessage[QueryServer](in, __queryServer.orElse({
				__queryServer = QueryServer.defaultInstance
				__queryServer
			}).get, _emptyRegistry))
			case 130 => __queryServerResponse = Some(readMessage[QueryServerResponse](in, __queryServerResponse.orElse({
				__queryServerResponse = QueryServerResponse.defaultInstance
				__queryServerResponse
			}).get, _emptyRegistry))
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: Message) = {
		Message(
			m.`msgtype`,
			m.`from`,
			m.`dest`,
			m.`response`.orElse(`response`),
			m.`ping`.orElse(`ping`),
			m.`pong`.orElse(`pong`),
			m.`newUser`.orElse(`newUser`),
			m.`login`.orElse(`login`),
			m.`say`.orElse(`say`),
			m.`mapRequest`.orElse(`mapRequest`),
			m.`mapIgnore`.orElse(`mapIgnore`),
			m.`map`.orElse(`map`),
			m.`mapUpdate`.orElse(`mapUpdate`),
			m.`mapCharacterUpdate`.orElse(`mapCharacterUpdate`),
			m.`queryServer`.orElse(`queryServer`),
			m.`queryServerResponse`.orElse(`queryServerResponse`)
		)
	}

	def getDefaultInstanceForType = Message.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
}

object Message {
	@scala.beans.BeanProperty val defaultInstance = new Message()

	def parseFrom(data: Array[Byte]): Message = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): Message = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): Message = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): Message = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[Message] = defaultInstance.mergeDelimitedFromStream(stream)

	val MSGTYPE_FIELD_NUMBER = 1
	val FROM_FIELD_NUMBER = 2
	val DEST_FIELD_NUMBER = 3
	val RESPONSE_FIELD_NUMBER = 4
	val PING_FIELD_NUMBER = 5
	val PONG_FIELD_NUMBER = 6
	val NEWUSER_FIELD_NUMBER = 7
	val LOGIN_FIELD_NUMBER = 8
	val SAY_FIELD_NUMBER = 9
	val MAPREQUEST_FIELD_NUMBER = 10
	val MAPIGNORE_FIELD_NUMBER = 11
	val MAP_FIELD_NUMBER = 12
	val MAPUPDATE_FIELD_NUMBER = 13
	val MAPCHARACTERUPDATE_FIELD_NUMBER = 14
	val QUERYSERVER_FIELD_NUMBER = 15
	val QUERYSERVERRESPONSE_FIELD_NUMBER = 16

	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: Message) = defaultInstance.mergeFrom(prototype)

}
final case class Ping (
	`count`: Int = 0
) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[Ping]
	with net.sandrogrzicic.scalabuff.Parser[Ping] {



	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		output.writeInt32(1, `count`)
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0
		__size += computeInt32Size(1, `count`)

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): Ping = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __count: Int = 0

		def __newMerged = Ping(
			__count
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 8 => __count = in.readInt32()
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: Ping) = {
		Ping(
			m.`count`
		)
	}

	def getDefaultInstanceForType = Ping.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
}

object Ping {
	@scala.beans.BeanProperty val defaultInstance = new Ping()

	def parseFrom(data: Array[Byte]): Ping = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): Ping = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): Ping = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): Ping = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[Ping] = defaultInstance.mergeDelimitedFromStream(stream)

	val COUNT_FIELD_NUMBER = 1

	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: Ping) = defaultInstance.mergeFrom(prototype)

}
final case class Pong (
	`count`: Int = 0
) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[Pong]
	with net.sandrogrzicic.scalabuff.Parser[Pong] {



	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		output.writeInt32(1, `count`)
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0
		__size += computeInt32Size(1, `count`)

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): Pong = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __count: Int = 0

		def __newMerged = Pong(
			__count
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 8 => __count = in.readInt32()
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: Pong) = {
		Pong(
			m.`count`
		)
	}

	def getDefaultInstanceForType = Pong.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
}

object Pong {
	@scala.beans.BeanProperty val defaultInstance = new Pong()

	def parseFrom(data: Array[Byte]): Pong = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): Pong = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): Pong = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): Pong = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[Pong] = defaultInstance.mergeDelimitedFromStream(stream)

	val COUNT_FIELD_NUMBER = 1

	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: Pong) = defaultInstance.mergeFrom(prototype)

}
final case class Response (
	`code`: Int = 0,
	`message`: Option[String] = None
) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[Response]
	with net.sandrogrzicic.scalabuff.Parser[Response] {

	def setMessage(_f: String) = copy(`message` = Some(_f))

	def clearMessage = copy(`message` = None)

	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		output.writeInt32(1, `code`)
		if (`message`.isDefined) output.writeString(2, `message`.get)
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0
		__size += computeInt32Size(1, `code`)
		if (`message`.isDefined) __size += computeStringSize(2, `message`.get)

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): Response = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __code: Int = 0
		var __message: Option[String] = `message`

		def __newMerged = Response(
			__code,
			__message
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 8 => __code = in.readInt32()
			case 18 => __message = Some(in.readString())
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: Response) = {
		Response(
			m.`code`,
			m.`message`.orElse(`message`)
		)
	}

	def getDefaultInstanceForType = Response.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
}

object Response {
	@scala.beans.BeanProperty val defaultInstance = new Response()

	def parseFrom(data: Array[Byte]): Response = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): Response = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): Response = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): Response = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[Response] = defaultInstance.mergeDelimitedFromStream(stream)

	val CODE_FIELD_NUMBER = 1
	val MESSAGE_FIELD_NUMBER = 2

	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: Response) = defaultInstance.mergeFrom(prototype)

}
final case class NewUser (
	`username`: String = "",
	`password`: String = "",
	`name`: String = ""
) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[NewUser]
	with net.sandrogrzicic.scalabuff.Parser[NewUser] {



	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		output.writeString(1, `username`)
		output.writeString(2, `password`)
		output.writeString(3, `name`)
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0
		__size += computeStringSize(1, `username`)
		__size += computeStringSize(2, `password`)
		__size += computeStringSize(3, `name`)

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): NewUser = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __username: String = ""
		var __password: String = ""
		var __name: String = ""

		def __newMerged = NewUser(
			__username,
			__password,
			__name
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 10 => __username = in.readString()
			case 18 => __password = in.readString()
			case 26 => __name = in.readString()
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: NewUser) = {
		NewUser(
			m.`username`,
			m.`password`,
			m.`name`
		)
	}

	def getDefaultInstanceForType = NewUser.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
}

object NewUser {
	@scala.beans.BeanProperty val defaultInstance = new NewUser()

	def parseFrom(data: Array[Byte]): NewUser = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): NewUser = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): NewUser = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): NewUser = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[NewUser] = defaultInstance.mergeDelimitedFromStream(stream)

	val USERNAME_FIELD_NUMBER = 1
	val PASSWORD_FIELD_NUMBER = 2
	val NAME_FIELD_NUMBER = 3

	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: NewUser) = defaultInstance.mergeFrom(prototype)

}
final case class Login (
	`username`: String = "",
	`password`: String = ""
) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[Login]
	with net.sandrogrzicic.scalabuff.Parser[Login] {



	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		output.writeString(1, `username`)
		output.writeString(2, `password`)
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0
		__size += computeStringSize(1, `username`)
		__size += computeStringSize(2, `password`)

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): Login = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __username: String = ""
		var __password: String = ""

		def __newMerged = Login(
			__username,
			__password
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 10 => __username = in.readString()
			case 18 => __password = in.readString()
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: Login) = {
		Login(
			m.`username`,
			m.`password`
		)
	}

	def getDefaultInstanceForType = Login.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
}

object Login {
	@scala.beans.BeanProperty val defaultInstance = new Login()

	def parseFrom(data: Array[Byte]): Login = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): Login = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): Login = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): Login = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[Login] = defaultInstance.mergeDelimitedFromStream(stream)

	val USERNAME_FIELD_NUMBER = 1
	val PASSWORD_FIELD_NUMBER = 2

	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: Login) = defaultInstance.mergeFrom(prototype)

}
final case class Say (
	`text`: String = ""
) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[Say]
	with net.sandrogrzicic.scalabuff.Parser[Say] {



	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		output.writeString(1, `text`)
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0
		__size += computeStringSize(1, `text`)

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): Say = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __text: String = ""

		def __newMerged = Say(
			__text
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 10 => __text = in.readString()
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: Say) = {
		Say(
			m.`text`
		)
	}

	def getDefaultInstanceForType = Say.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
}

object Say {
	@scala.beans.BeanProperty val defaultInstance = new Say()

	def parseFrom(data: Array[Byte]): Say = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): Say = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): Say = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): Say = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[Say] = defaultInstance.mergeDelimitedFromStream(stream)

	val TEXT_FIELD_NUMBER = 1

	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: Say) = defaultInstance.mergeFrom(prototype)

}
final case class MapRequest (
	`x`: Int = 0,
	`y`: Int = 0
) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[MapRequest]
	with net.sandrogrzicic.scalabuff.Parser[MapRequest] {



	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		output.writeInt32(1, `x`)
		output.writeInt32(2, `y`)
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0
		__size += computeInt32Size(1, `x`)
		__size += computeInt32Size(2, `y`)

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): MapRequest = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __x: Int = 0
		var __y: Int = 0

		def __newMerged = MapRequest(
			__x,
			__y
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 8 => __x = in.readInt32()
			case 16 => __y = in.readInt32()
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: MapRequest) = {
		MapRequest(
			m.`x`,
			m.`y`
		)
	}

	def getDefaultInstanceForType = MapRequest.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
}

object MapRequest {
	@scala.beans.BeanProperty val defaultInstance = new MapRequest()

	def parseFrom(data: Array[Byte]): MapRequest = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): MapRequest = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): MapRequest = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): MapRequest = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[MapRequest] = defaultInstance.mergeDelimitedFromStream(stream)

	val X_FIELD_NUMBER = 1
	val Y_FIELD_NUMBER = 2

	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: MapRequest) = defaultInstance.mergeFrom(prototype)

}
final case class MapIgnore (
	`x`: Int = 0,
	`y`: Int = 0
) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[MapIgnore]
	with net.sandrogrzicic.scalabuff.Parser[MapIgnore] {



	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		output.writeInt32(1, `x`)
		output.writeInt32(2, `y`)
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0
		__size += computeInt32Size(1, `x`)
		__size += computeInt32Size(2, `y`)

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): MapIgnore = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __x: Int = 0
		var __y: Int = 0

		def __newMerged = MapIgnore(
			__x,
			__y
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 8 => __x = in.readInt32()
			case 16 => __y = in.readInt32()
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: MapIgnore) = {
		MapIgnore(
			m.`x`,
			m.`y`
		)
	}

	def getDefaultInstanceForType = MapIgnore.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
}

object MapIgnore {
	@scala.beans.BeanProperty val defaultInstance = new MapIgnore()

	def parseFrom(data: Array[Byte]): MapIgnore = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): MapIgnore = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): MapIgnore = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): MapIgnore = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[MapIgnore] = defaultInstance.mergeDelimitedFromStream(stream)

	val X_FIELD_NUMBER = 1
	val Y_FIELD_NUMBER = 2

	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: MapIgnore) = defaultInstance.mergeFrom(prototype)

}
final case class Map (
	`minX`: Int = 0,
	`minY`: Int = 0,
	`maxX`: Int = 0,
	`maxY`: Int = 0,
	`dataSize`: Int = 0
) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[Map]
	with net.sandrogrzicic.scalabuff.Parser[Map] {



	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		output.writeInt32(1, `minX`)
		output.writeInt32(2, `minY`)
		output.writeInt32(3, `maxX`)
		output.writeInt32(4, `maxY`)
		output.writeInt32(5, `dataSize`)
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0
		__size += computeInt32Size(1, `minX`)
		__size += computeInt32Size(2, `minY`)
		__size += computeInt32Size(3, `maxX`)
		__size += computeInt32Size(4, `maxY`)
		__size += computeInt32Size(5, `dataSize`)

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): Map = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __minX: Int = 0
		var __minY: Int = 0
		var __maxX: Int = 0
		var __maxY: Int = 0
		var __dataSize: Int = 0

		def __newMerged = Map(
			__minX,
			__minY,
			__maxX,
			__maxY,
			__dataSize
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 8 => __minX = in.readInt32()
			case 16 => __minY = in.readInt32()
			case 24 => __maxX = in.readInt32()
			case 32 => __maxY = in.readInt32()
			case 40 => __dataSize = in.readInt32()
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: Map) = {
		Map(
			m.`minX`,
			m.`minY`,
			m.`maxX`,
			m.`maxY`,
			m.`dataSize`
		)
	}

	def getDefaultInstanceForType = Map.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
}

object Map {
	@scala.beans.BeanProperty val defaultInstance = new Map()

	def parseFrom(data: Array[Byte]): Map = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): Map = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): Map = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): Map = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[Map] = defaultInstance.mergeDelimitedFromStream(stream)

	val MINX_FIELD_NUMBER = 1
	val MINY_FIELD_NUMBER = 2
	val MAXX_FIELD_NUMBER = 3
	val MAXY_FIELD_NUMBER = 4
	val DATASIZE_FIELD_NUMBER = 5

	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: Map) = defaultInstance.mergeFrom(prototype)

}
final case class MapUpdate (
	`x`: Int = 0,
	`y`: Int = 0,
	`z`: Int = 0,
	`newBlock`: Int = 0
) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[MapUpdate]
	with net.sandrogrzicic.scalabuff.Parser[MapUpdate] {



	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		output.writeInt32(1, `x`)
		output.writeInt32(2, `y`)
		output.writeInt32(3, `z`)
		output.writeInt32(4, `newBlock`)
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0
		__size += computeInt32Size(1, `x`)
		__size += computeInt32Size(2, `y`)
		__size += computeInt32Size(3, `z`)
		__size += computeInt32Size(4, `newBlock`)

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): MapUpdate = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __x: Int = 0
		var __y: Int = 0
		var __z: Int = 0
		var __newBlock: Int = 0

		def __newMerged = MapUpdate(
			__x,
			__y,
			__z,
			__newBlock
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 8 => __x = in.readInt32()
			case 16 => __y = in.readInt32()
			case 24 => __z = in.readInt32()
			case 32 => __newBlock = in.readInt32()
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: MapUpdate) = {
		MapUpdate(
			m.`x`,
			m.`y`,
			m.`z`,
			m.`newBlock`
		)
	}

	def getDefaultInstanceForType = MapUpdate.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
}

object MapUpdate {
	@scala.beans.BeanProperty val defaultInstance = new MapUpdate()

	def parseFrom(data: Array[Byte]): MapUpdate = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): MapUpdate = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): MapUpdate = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): MapUpdate = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[MapUpdate] = defaultInstance.mergeDelimitedFromStream(stream)

	val X_FIELD_NUMBER = 1
	val Y_FIELD_NUMBER = 2
	val Z_FIELD_NUMBER = 3
	val NEWBLOCK_FIELD_NUMBER = 4

	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: MapUpdate) = defaultInstance.mergeFrom(prototype)

}
final case class MapCharacterUpdate (
	`id`: Int = 0,
	`x`: Int = 0,
	`y`: Int = 0,
	`z`: Int = 0
) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[MapCharacterUpdate]
	with net.sandrogrzicic.scalabuff.Parser[MapCharacterUpdate] {



	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		output.writeInt32(1, `id`)
		output.writeInt32(2, `x`)
		output.writeInt32(3, `y`)
		output.writeInt32(4, `z`)
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0
		__size += computeInt32Size(1, `id`)
		__size += computeInt32Size(2, `x`)
		__size += computeInt32Size(3, `y`)
		__size += computeInt32Size(4, `z`)

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): MapCharacterUpdate = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __id: Int = 0
		var __x: Int = 0
		var __y: Int = 0
		var __z: Int = 0

		def __newMerged = MapCharacterUpdate(
			__id,
			__x,
			__y,
			__z
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 8 => __id = in.readInt32()
			case 16 => __x = in.readInt32()
			case 24 => __y = in.readInt32()
			case 32 => __z = in.readInt32()
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: MapCharacterUpdate) = {
		MapCharacterUpdate(
			m.`id`,
			m.`x`,
			m.`y`,
			m.`z`
		)
	}

	def getDefaultInstanceForType = MapCharacterUpdate.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
}

object MapCharacterUpdate {
	@scala.beans.BeanProperty val defaultInstance = new MapCharacterUpdate()

	def parseFrom(data: Array[Byte]): MapCharacterUpdate = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): MapCharacterUpdate = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): MapCharacterUpdate = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): MapCharacterUpdate = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[MapCharacterUpdate] = defaultInstance.mergeDelimitedFromStream(stream)

	val ID_FIELD_NUMBER = 1
	val X_FIELD_NUMBER = 2
	val Y_FIELD_NUMBER = 3
	val Z_FIELD_NUMBER = 4

	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: MapCharacterUpdate) = defaultInstance.mergeFrom(prototype)

}
final case class QueryServer (

) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[QueryServer]
	with net.sandrogrzicic.scalabuff.Parser[QueryServer] {



	def writeTo(output: com.google.protobuf.CodedOutputStream) {
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): QueryServer = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}

		def __newMerged = QueryServer(

		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: QueryServer) = {
		QueryServer(

		)
	}

	def getDefaultInstanceForType = QueryServer.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
}

object QueryServer {
	@scala.beans.BeanProperty val defaultInstance = new QueryServer()

	def parseFrom(data: Array[Byte]): QueryServer = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): QueryServer = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): QueryServer = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): QueryServer = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[QueryServer] = defaultInstance.mergeDelimitedFromStream(stream)


	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: QueryServer) = defaultInstance.mergeFrom(prototype)

}
final case class QueryServerResponse (
	`minMapChunkX`: Int = 0,
	`minMapChunkY`: Int = 0,
	`maxMapChunkX`: Int = 0,
	`maxMapChunkY`: Int = 0
) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[QueryServerResponse]
	with net.sandrogrzicic.scalabuff.Parser[QueryServerResponse] {



	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		output.writeInt32(1, `minMapChunkX`)
		output.writeInt32(2, `minMapChunkY`)
		output.writeInt32(3, `maxMapChunkX`)
		output.writeInt32(4, `maxMapChunkY`)
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0
		__size += computeInt32Size(1, `minMapChunkX`)
		__size += computeInt32Size(2, `minMapChunkY`)
		__size += computeInt32Size(3, `maxMapChunkX`)
		__size += computeInt32Size(4, `maxMapChunkY`)

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): QueryServerResponse = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __minMapChunkX: Int = 0
		var __minMapChunkY: Int = 0
		var __maxMapChunkX: Int = 0
		var __maxMapChunkY: Int = 0

		def __newMerged = QueryServerResponse(
			__minMapChunkX,
			__minMapChunkY,
			__maxMapChunkX,
			__maxMapChunkY
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 8 => __minMapChunkX = in.readInt32()
			case 16 => __minMapChunkY = in.readInt32()
			case 24 => __maxMapChunkX = in.readInt32()
			case 32 => __maxMapChunkY = in.readInt32()
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: QueryServerResponse) = {
		QueryServerResponse(
			m.`minMapChunkX`,
			m.`minMapChunkY`,
			m.`maxMapChunkX`,
			m.`maxMapChunkY`
		)
	}

	def getDefaultInstanceForType = QueryServerResponse.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
}

object QueryServerResponse {
	@scala.beans.BeanProperty val defaultInstance = new QueryServerResponse()

	def parseFrom(data: Array[Byte]): QueryServerResponse = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): QueryServerResponse = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): QueryServerResponse = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): QueryServerResponse = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[QueryServerResponse] = defaultInstance.mergeDelimitedFromStream(stream)

	val MINMAPCHUNKX_FIELD_NUMBER = 1
	val MINMAPCHUNKY_FIELD_NUMBER = 2
	val MAXMAPCHUNKX_FIELD_NUMBER = 3
	val MAXMAPCHUNKY_FIELD_NUMBER = 4

	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: QueryServerResponse) = defaultInstance.mergeFrom(prototype)

}

object CommsMessages {
	def registerAllExtensions(registry: com.google.protobuf.ExtensionRegistryLite) {
	}

	private val fromBinaryHintMap = collection.immutable.HashMap[String, Array[Byte] ⇒ com.google.protobuf.GeneratedMessageLite](
		 "Message" -> (bytes ⇒ Message.parseFrom(bytes)),
		 "Ping" -> (bytes ⇒ Ping.parseFrom(bytes)),
		 "Pong" -> (bytes ⇒ Pong.parseFrom(bytes)),
		 "Response" -> (bytes ⇒ Response.parseFrom(bytes)),
		 "NewUser" -> (bytes ⇒ NewUser.parseFrom(bytes)),
		 "Login" -> (bytes ⇒ Login.parseFrom(bytes)),
		 "Say" -> (bytes ⇒ Say.parseFrom(bytes)),
		 "MapRequest" -> (bytes ⇒ MapRequest.parseFrom(bytes)),
		 "MapIgnore" -> (bytes ⇒ MapIgnore.parseFrom(bytes)),
		 "Map" -> (bytes ⇒ Map.parseFrom(bytes)),
		 "MapUpdate" -> (bytes ⇒ MapUpdate.parseFrom(bytes)),
		 "MapCharacterUpdate" -> (bytes ⇒ MapCharacterUpdate.parseFrom(bytes)),
		 "QueryServer" -> (bytes ⇒ QueryServer.parseFrom(bytes)),
		 "QueryServerResponse" -> (bytes ⇒ QueryServerResponse.parseFrom(bytes))
	)

	def deserializePayload(payload: Array[Byte], payloadType: String): com.google.protobuf.GeneratedMessageLite = {
		fromBinaryHintMap.get(payloadType) match {
			case Some(f) ⇒ f(payload)
			case None    ⇒ throw new IllegalArgumentException(s"unimplemented deserialization of message payload of type [${payloadType}]")
		}
	}
}
