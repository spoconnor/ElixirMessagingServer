// Generated by ScalaBuff, the Scala Protocol Buffers compiler. DO NOT EDIT!
// source: CommsMessages.proto

package CommsMessages

object MsgType extends net.sandrogrzicic.scalabuff.Enum {
	sealed trait EnumVal extends Value
	val _UNINITIALIZED = new EnumVal { val name = "UNINITIALIZED ENUM VALUE"; val id = -1 }

	val eResponse = new EnumVal { val name = "eResponse"; val id = 1 }
	val ePing = new EnumVal { val name = "ePing"; val id = 2 }
	val ePong = new EnumVal { val name = "ePong"; val id = 3 }
	val eNewUser = new EnumVal { val name = "eNewUser"; val id = 4 }
	val eLogin = new EnumVal { val name = "eLogin"; val id = 5 }
	val eSay = new EnumVal { val name = "eSay"; val id = 6 }
	val eMapRequestUpdates = new EnumVal { val name = "eMapRequestUpdates"; val id = 7 }
	val eMapIgnoreUpdates = new EnumVal { val name = "eMapIgnoreUpdates"; val id = 8 }
	val eMap = new EnumVal { val name = "eMap"; val id = 9 }
	val eQueryServer = new EnumVal { val name = "eQueryServer"; val id = 10 }
	val eQueryServerResponse = new EnumVal { val name = "eQueryServerResponse"; val id = 11 }

	val eResponse_VALUE = 1
	val ePing_VALUE = 2
	val ePong_VALUE = 3
	val eNewUser_VALUE = 4
	val eLogin_VALUE = 5
	val eSay_VALUE = 6
	val eMapRequestUpdates_VALUE = 7
	val eMapIgnoreUpdates_VALUE = 8
	val eMap_VALUE = 9
	val eQueryServer_VALUE = 10
	val eQueryServerResponse_VALUE = 11

	def valueOf(id: Int) = id match {
		case 1 => eResponse
		case 2 => ePing
		case 3 => ePong
		case 4 => eNewUser
		case 5 => eLogin
		case 6 => eSay
		case 7 => eMapRequestUpdates
		case 8 => eMapIgnoreUpdates
		case 9 => eMap
		case 10 => eQueryServer
		case 11 => eQueryServerResponse
		case _default => throw new net.sandrogrzicic.scalabuff.UnknownEnumException(_default)
	}
	val internalGetValueMap = new com.google.protobuf.Internal.EnumLiteMap[EnumVal] {
		def findValueByNumber(id: Int): EnumVal = valueOf(id)
	}
}
final case class Message (
	`msgtype`: Int = 0,
	`from`: String = "",
	`dest`: String = "",
	`response`: Option[Response] = None,
	`ping`: Option[Ping] = None,
	`pong`: Option[Pong] = None,
	`newUser`: Option[NewUser] = None,
	`login`: Option[Login] = None,
	`say`: Option[Say] = None,
	`mapRequestUpdates`: Option[MapRequestUpdates] = None,
	`mapIgnoreUpdates`: Option[MapIgnoreUpdates] = None,
	`map`: Option[Map] = None,
	`queryServer`: Option[QueryServer] = None,
	`queryServerResponse`: Option[QueryServerResponse] = None
) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[Message]
	with net.sandrogrzicic.scalabuff.Parser[Message] {

	def setResponse(_f: Response) = copy(`response` = Some(_f))
	def setPing(_f: Ping) = copy(`ping` = Some(_f))
	def setPong(_f: Pong) = copy(`pong` = Some(_f))
	def setNewUser(_f: NewUser) = copy(`newUser` = Some(_f))
	def setLogin(_f: Login) = copy(`login` = Some(_f))
	def setSay(_f: Say) = copy(`say` = Some(_f))
	def setMapRequestUpdates(_f: MapRequestUpdates) = copy(`mapRequestUpdates` = Some(_f))
	def setMapIgnoreUpdates(_f: MapIgnoreUpdates) = copy(`mapIgnoreUpdates` = Some(_f))
	def setMap(_f: Map) = copy(`map` = Some(_f))
	def setQueryServer(_f: QueryServer) = copy(`queryServer` = Some(_f))
	def setQueryServerResponse(_f: QueryServerResponse) = copy(`queryServerResponse` = Some(_f))

	def clearResponse = copy(`response` = None)
	def clearPing = copy(`ping` = None)
	def clearPong = copy(`pong` = None)
	def clearNewUser = copy(`newUser` = None)
	def clearLogin = copy(`login` = None)
	def clearSay = copy(`say` = None)
	def clearMapRequestUpdates = copy(`mapRequestUpdates` = None)
	def clearMapIgnoreUpdates = copy(`mapIgnoreUpdates` = None)
	def clearMap = copy(`map` = None)
	def clearQueryServer = copy(`queryServer` = None)
	def clearQueryServerResponse = copy(`queryServerResponse` = None)

	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		output.writeInt32(1, `msgtype`)
		output.writeString(2, `from`)
		output.writeString(3, `dest`)
		if (`response`.isDefined) output.writeMessage(4, `response`.get)
		if (`ping`.isDefined) output.writeMessage(5, `ping`.get)
		if (`pong`.isDefined) output.writeMessage(6, `pong`.get)
		if (`newUser`.isDefined) output.writeMessage(7, `newUser`.get)
		if (`login`.isDefined) output.writeMessage(8, `login`.get)
		if (`say`.isDefined) output.writeMessage(9, `say`.get)
		if (`mapRequestUpdates`.isDefined) output.writeMessage(10, `mapRequestUpdates`.get)
		if (`mapIgnoreUpdates`.isDefined) output.writeMessage(11, `mapIgnoreUpdates`.get)
		if (`map`.isDefined) output.writeMessage(12, `map`.get)
		if (`queryServer`.isDefined) output.writeMessage(13, `queryServer`.get)
		if (`queryServerResponse`.isDefined) output.writeMessage(14, `queryServerResponse`.get)
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0
		__size += computeInt32Size(1, `msgtype`)
		__size += computeStringSize(2, `from`)
		__size += computeStringSize(3, `dest`)
		if (`response`.isDefined) __size += computeMessageSize(4, `response`.get)
		if (`ping`.isDefined) __size += computeMessageSize(5, `ping`.get)
		if (`pong`.isDefined) __size += computeMessageSize(6, `pong`.get)
		if (`newUser`.isDefined) __size += computeMessageSize(7, `newUser`.get)
		if (`login`.isDefined) __size += computeMessageSize(8, `login`.get)
		if (`say`.isDefined) __size += computeMessageSize(9, `say`.get)
		if (`mapRequestUpdates`.isDefined) __size += computeMessageSize(10, `mapRequestUpdates`.get)
		if (`mapIgnoreUpdates`.isDefined) __size += computeMessageSize(11, `mapIgnoreUpdates`.get)
		if (`map`.isDefined) __size += computeMessageSize(12, `map`.get)
		if (`queryServer`.isDefined) __size += computeMessageSize(13, `queryServer`.get)
		if (`queryServerResponse`.isDefined) __size += computeMessageSize(14, `queryServerResponse`.get)

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): Message = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __msgtype: Int = 0
		var __from: String = ""
		var __dest: String = ""
		var __response: Option[Response] = `response`
		var __ping: Option[Ping] = `ping`
		var __pong: Option[Pong] = `pong`
		var __newUser: Option[NewUser] = `newUser`
		var __login: Option[Login] = `login`
		var __say: Option[Say] = `say`
		var __mapRequestUpdates: Option[MapRequestUpdates] = `mapRequestUpdates`
		var __mapIgnoreUpdates: Option[MapIgnoreUpdates] = `mapIgnoreUpdates`
		var __map: Option[Map] = `map`
		var __queryServer: Option[QueryServer] = `queryServer`
		var __queryServerResponse: Option[QueryServerResponse] = `queryServerResponse`

		def __newMerged = Message(
			__msgtype,
			__from,
			__dest,
			__response,
			__ping,
			__pong,
			__newUser,
			__login,
			__say,
			__mapRequestUpdates,
			__mapIgnoreUpdates,
			__map,
			__queryServer,
			__queryServerResponse
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 8 => __msgtype = in.readInt32()
			case 18 => __from = in.readString()
			case 26 => __dest = in.readString()
			case 34 => __response = Some(readMessage[Response](in, __response.orElse({
				__response = Response.defaultInstance
				__response
			}).get, _emptyRegistry))
			case 42 => __ping = Some(readMessage[Ping](in, __ping.orElse({
				__ping = Ping.defaultInstance
				__ping
			}).get, _emptyRegistry))
			case 50 => __pong = Some(readMessage[Pong](in, __pong.orElse({
				__pong = Pong.defaultInstance
				__pong
			}).get, _emptyRegistry))
			case 58 => __newUser = Some(readMessage[NewUser](in, __newUser.orElse({
				__newUser = NewUser.defaultInstance
				__newUser
			}).get, _emptyRegistry))
			case 66 => __login = Some(readMessage[Login](in, __login.orElse({
				__login = Login.defaultInstance
				__login
			}).get, _emptyRegistry))
			case 74 => __say = Some(readMessage[Say](in, __say.orElse({
				__say = Say.defaultInstance
				__say
			}).get, _emptyRegistry))
			case 82 => __mapRequestUpdates = Some(readMessage[MapRequestUpdates](in, __mapRequestUpdates.orElse({
				__mapRequestUpdates = MapRequestUpdates.defaultInstance
				__mapRequestUpdates
			}).get, _emptyRegistry))
			case 90 => __mapIgnoreUpdates = Some(readMessage[MapIgnoreUpdates](in, __mapIgnoreUpdates.orElse({
				__mapIgnoreUpdates = MapIgnoreUpdates.defaultInstance
				__mapIgnoreUpdates
			}).get, _emptyRegistry))
			case 98 => __map = Some(readMessage[Map](in, __map.orElse({
				__map = Map.defaultInstance
				__map
			}).get, _emptyRegistry))
			case 106 => __queryServer = Some(readMessage[QueryServer](in, __queryServer.orElse({
				__queryServer = QueryServer.defaultInstance
				__queryServer
			}).get, _emptyRegistry))
			case 114 => __queryServerResponse = Some(readMessage[QueryServerResponse](in, __queryServerResponse.orElse({
				__queryServerResponse = QueryServerResponse.defaultInstance
				__queryServerResponse
			}).get, _emptyRegistry))
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: Message) = {
		Message(
			m.`msgtype`,
			m.`from`,
			m.`dest`,
			m.`response`.orElse(`response`),
			m.`ping`.orElse(`ping`),
			m.`pong`.orElse(`pong`),
			m.`newUser`.orElse(`newUser`),
			m.`login`.orElse(`login`),
			m.`say`.orElse(`say`),
			m.`mapRequestUpdates`.orElse(`mapRequestUpdates`),
			m.`mapIgnoreUpdates`.orElse(`mapIgnoreUpdates`),
			m.`map`.orElse(`map`),
			m.`queryServer`.orElse(`queryServer`),
			m.`queryServerResponse`.orElse(`queryServerResponse`)
		)
	}

	def getDefaultInstanceForType = Message.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
}

object Message {
	@scala.beans.BeanProperty val defaultInstance = new Message()

	def parseFrom(data: Array[Byte]): Message = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): Message = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): Message = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): Message = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[Message] = defaultInstance.mergeDelimitedFromStream(stream)

	val MSGTYPE_FIELD_NUMBER = 1
	val FROM_FIELD_NUMBER = 2
	val DEST_FIELD_NUMBER = 3
	val RESPONSE_FIELD_NUMBER = 4
	val PING_FIELD_NUMBER = 5
	val PONG_FIELD_NUMBER = 6
	val NEWUSER_FIELD_NUMBER = 7
	val LOGIN_FIELD_NUMBER = 8
	val SAY_FIELD_NUMBER = 9
	val MAPREQUESTUPDATES_FIELD_NUMBER = 10
	val MAPIGNOREUPDATES_FIELD_NUMBER = 11
	val MAP_FIELD_NUMBER = 12
	val QUERYSERVER_FIELD_NUMBER = 13
	val QUERYSERVERRESPONSE_FIELD_NUMBER = 14

	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: Message) = defaultInstance.mergeFrom(prototype)

}
final case class Ping (
	`count`: Int = 0
) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[Ping]
	with net.sandrogrzicic.scalabuff.Parser[Ping] {



	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		output.writeInt32(1, `count`)
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0
		__size += computeInt32Size(1, `count`)

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): Ping = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __count: Int = 0

		def __newMerged = Ping(
			__count
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 8 => __count = in.readInt32()
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: Ping) = {
		Ping(
			m.`count`
		)
	}

	def getDefaultInstanceForType = Ping.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
}

object Ping {
	@scala.beans.BeanProperty val defaultInstance = new Ping()

	def parseFrom(data: Array[Byte]): Ping = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): Ping = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): Ping = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): Ping = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[Ping] = defaultInstance.mergeDelimitedFromStream(stream)

	val COUNT_FIELD_NUMBER = 1

	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: Ping) = defaultInstance.mergeFrom(prototype)

}
final case class Pong (
	`count`: Int = 0
) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[Pong]
	with net.sandrogrzicic.scalabuff.Parser[Pong] {



	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		output.writeInt32(1, `count`)
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0
		__size += computeInt32Size(1, `count`)

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): Pong = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __count: Int = 0

		def __newMerged = Pong(
			__count
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 8 => __count = in.readInt32()
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: Pong) = {
		Pong(
			m.`count`
		)
	}

	def getDefaultInstanceForType = Pong.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
}

object Pong {
	@scala.beans.BeanProperty val defaultInstance = new Pong()

	def parseFrom(data: Array[Byte]): Pong = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): Pong = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): Pong = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): Pong = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[Pong] = defaultInstance.mergeDelimitedFromStream(stream)

	val COUNT_FIELD_NUMBER = 1

	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: Pong) = defaultInstance.mergeFrom(prototype)

}
final case class Response (
	`code`: Int = 0,
	`message`: Option[String] = None
) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[Response]
	with net.sandrogrzicic.scalabuff.Parser[Response] {

	def setMessage(_f: String) = copy(`message` = Some(_f))

	def clearMessage = copy(`message` = None)

	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		output.writeInt32(1, `code`)
		if (`message`.isDefined) output.writeString(2, `message`.get)
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0
		__size += computeInt32Size(1, `code`)
		if (`message`.isDefined) __size += computeStringSize(2, `message`.get)

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): Response = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __code: Int = 0
		var __message: Option[String] = `message`

		def __newMerged = Response(
			__code,
			__message
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 8 => __code = in.readInt32()
			case 18 => __message = Some(in.readString())
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: Response) = {
		Response(
			m.`code`,
			m.`message`.orElse(`message`)
		)
	}

	def getDefaultInstanceForType = Response.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
}

object Response {
	@scala.beans.BeanProperty val defaultInstance = new Response()

	def parseFrom(data: Array[Byte]): Response = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): Response = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): Response = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): Response = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[Response] = defaultInstance.mergeDelimitedFromStream(stream)

	val CODE_FIELD_NUMBER = 1
	val MESSAGE_FIELD_NUMBER = 2

	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: Response) = defaultInstance.mergeFrom(prototype)

}
final case class NewUser (
	`username`: String = "",
	`password`: String = "",
	`name`: String = ""
) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[NewUser]
	with net.sandrogrzicic.scalabuff.Parser[NewUser] {



	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		output.writeString(1, `username`)
		output.writeString(2, `password`)
		output.writeString(3, `name`)
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0
		__size += computeStringSize(1, `username`)
		__size += computeStringSize(2, `password`)
		__size += computeStringSize(3, `name`)

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): NewUser = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __username: String = ""
		var __password: String = ""
		var __name: String = ""

		def __newMerged = NewUser(
			__username,
			__password,
			__name
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 10 => __username = in.readString()
			case 18 => __password = in.readString()
			case 26 => __name = in.readString()
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: NewUser) = {
		NewUser(
			m.`username`,
			m.`password`,
			m.`name`
		)
	}

	def getDefaultInstanceForType = NewUser.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
}

object NewUser {
	@scala.beans.BeanProperty val defaultInstance = new NewUser()

	def parseFrom(data: Array[Byte]): NewUser = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): NewUser = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): NewUser = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): NewUser = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[NewUser] = defaultInstance.mergeDelimitedFromStream(stream)

	val USERNAME_FIELD_NUMBER = 1
	val PASSWORD_FIELD_NUMBER = 2
	val NAME_FIELD_NUMBER = 3

	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: NewUser) = defaultInstance.mergeFrom(prototype)

}
final case class Login (
	`username`: String = "",
	`password`: String = ""
) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[Login]
	with net.sandrogrzicic.scalabuff.Parser[Login] {



	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		output.writeString(1, `username`)
		output.writeString(2, `password`)
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0
		__size += computeStringSize(1, `username`)
		__size += computeStringSize(2, `password`)

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): Login = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __username: String = ""
		var __password: String = ""

		def __newMerged = Login(
			__username,
			__password
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 10 => __username = in.readString()
			case 18 => __password = in.readString()
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: Login) = {
		Login(
			m.`username`,
			m.`password`
		)
	}

	def getDefaultInstanceForType = Login.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
}

object Login {
	@scala.beans.BeanProperty val defaultInstance = new Login()

	def parseFrom(data: Array[Byte]): Login = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): Login = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): Login = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): Login = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[Login] = defaultInstance.mergeDelimitedFromStream(stream)

	val USERNAME_FIELD_NUMBER = 1
	val PASSWORD_FIELD_NUMBER = 2

	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: Login) = defaultInstance.mergeFrom(prototype)

}
final case class Say (
	`text`: String = ""
) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[Say]
	with net.sandrogrzicic.scalabuff.Parser[Say] {



	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		output.writeString(1, `text`)
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0
		__size += computeStringSize(1, `text`)

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): Say = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __text: String = ""

		def __newMerged = Say(
			__text
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 10 => __text = in.readString()
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: Say) = {
		Say(
			m.`text`
		)
	}

	def getDefaultInstanceForType = Say.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
}

object Say {
	@scala.beans.BeanProperty val defaultInstance = new Say()

	def parseFrom(data: Array[Byte]): Say = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): Say = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): Say = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): Say = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[Say] = defaultInstance.mergeDelimitedFromStream(stream)

	val TEXT_FIELD_NUMBER = 1

	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: Say) = defaultInstance.mergeFrom(prototype)

}
final case class MapRequestUpdates (
	`mapChunkX`: Int = 0,
	`mapChunkY`: Int = 0
) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[MapRequestUpdates]
	with net.sandrogrzicic.scalabuff.Parser[MapRequestUpdates] {



	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		output.writeInt32(1, `mapChunkX`)
		output.writeInt32(2, `mapChunkY`)
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0
		__size += computeInt32Size(1, `mapChunkX`)
		__size += computeInt32Size(2, `mapChunkY`)

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): MapRequestUpdates = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __mapChunkX: Int = 0
		var __mapChunkY: Int = 0

		def __newMerged = MapRequestUpdates(
			__mapChunkX,
			__mapChunkY
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 8 => __mapChunkX = in.readInt32()
			case 16 => __mapChunkY = in.readInt32()
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: MapRequestUpdates) = {
		MapRequestUpdates(
			m.`mapChunkX`,
			m.`mapChunkY`
		)
	}

	def getDefaultInstanceForType = MapRequestUpdates.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
}

object MapRequestUpdates {
	@scala.beans.BeanProperty val defaultInstance = new MapRequestUpdates()

	def parseFrom(data: Array[Byte]): MapRequestUpdates = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): MapRequestUpdates = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): MapRequestUpdates = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): MapRequestUpdates = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[MapRequestUpdates] = defaultInstance.mergeDelimitedFromStream(stream)

	val MAPCHUNKX_FIELD_NUMBER = 1
	val MAPCHUNKY_FIELD_NUMBER = 2

	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: MapRequestUpdates) = defaultInstance.mergeFrom(prototype)

}
final case class MapIgnoreUpdates (
	`mapChunkX`: Int = 0,
	`mapChunkY`: Int = 0
) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[MapIgnoreUpdates]
	with net.sandrogrzicic.scalabuff.Parser[MapIgnoreUpdates] {



	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		output.writeInt32(1, `mapChunkX`)
		output.writeInt32(2, `mapChunkY`)
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0
		__size += computeInt32Size(1, `mapChunkX`)
		__size += computeInt32Size(2, `mapChunkY`)

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): MapIgnoreUpdates = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __mapChunkX: Int = 0
		var __mapChunkY: Int = 0

		def __newMerged = MapIgnoreUpdates(
			__mapChunkX,
			__mapChunkY
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 8 => __mapChunkX = in.readInt32()
			case 16 => __mapChunkY = in.readInt32()
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: MapIgnoreUpdates) = {
		MapIgnoreUpdates(
			m.`mapChunkX`,
			m.`mapChunkY`
		)
	}

	def getDefaultInstanceForType = MapIgnoreUpdates.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
}

object MapIgnoreUpdates {
	@scala.beans.BeanProperty val defaultInstance = new MapIgnoreUpdates()

	def parseFrom(data: Array[Byte]): MapIgnoreUpdates = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): MapIgnoreUpdates = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): MapIgnoreUpdates = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): MapIgnoreUpdates = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[MapIgnoreUpdates] = defaultInstance.mergeDelimitedFromStream(stream)

	val MAPCHUNKX_FIELD_NUMBER = 1
	val MAPCHUNKY_FIELD_NUMBER = 2

	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: MapIgnoreUpdates) = defaultInstance.mergeFrom(prototype)

}
final case class Map (
	`mapChunkX`: Int = 0,
	`mapChunkY`: Int = 0,
	`dataSize`: Int = 0
) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[Map]
	with net.sandrogrzicic.scalabuff.Parser[Map] {



	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		output.writeInt32(1, `mapChunkX`)
		output.writeInt32(2, `mapChunkY`)
		output.writeInt32(3, `dataSize`)
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0
		__size += computeInt32Size(1, `mapChunkX`)
		__size += computeInt32Size(2, `mapChunkY`)
		__size += computeInt32Size(3, `dataSize`)

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): Map = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __mapChunkX: Int = 0
		var __mapChunkY: Int = 0
		var __dataSize: Int = 0

		def __newMerged = Map(
			__mapChunkX,
			__mapChunkY,
			__dataSize
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 8 => __mapChunkX = in.readInt32()
			case 16 => __mapChunkY = in.readInt32()
			case 24 => __dataSize = in.readInt32()
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: Map) = {
		Map(
			m.`mapChunkX`,
			m.`mapChunkY`,
			m.`dataSize`
		)
	}

	def getDefaultInstanceForType = Map.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
}

object Map {
	@scala.beans.BeanProperty val defaultInstance = new Map()

	def parseFrom(data: Array[Byte]): Map = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): Map = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): Map = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): Map = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[Map] = defaultInstance.mergeDelimitedFromStream(stream)

	val MAPCHUNKX_FIELD_NUMBER = 1
	val MAPCHUNKY_FIELD_NUMBER = 2
	val DATASIZE_FIELD_NUMBER = 3

	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: Map) = defaultInstance.mergeFrom(prototype)

}
final case class QueryServer (

) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[QueryServer]
	with net.sandrogrzicic.scalabuff.Parser[QueryServer] {



	def writeTo(output: com.google.protobuf.CodedOutputStream) {
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): QueryServer = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}

		def __newMerged = QueryServer(

		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: QueryServer) = {
		QueryServer(

		)
	}

	def getDefaultInstanceForType = QueryServer.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
}

object QueryServer {
	@scala.beans.BeanProperty val defaultInstance = new QueryServer()

	def parseFrom(data: Array[Byte]): QueryServer = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): QueryServer = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): QueryServer = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): QueryServer = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[QueryServer] = defaultInstance.mergeDelimitedFromStream(stream)


	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: QueryServer) = defaultInstance.mergeFrom(prototype)

}
final case class QueryServerResponse (
	`minMapChunkX`: Int = 0,
	`minMapChunkY`: Int = 0,
	`maxMapChunkX`: Int = 0,
	`maxMapChunkY`: Int = 0
) extends com.google.protobuf.GeneratedMessageLite
	with com.google.protobuf.MessageLite.Builder
	with net.sandrogrzicic.scalabuff.Message[QueryServerResponse]
	with net.sandrogrzicic.scalabuff.Parser[QueryServerResponse] {



	def writeTo(output: com.google.protobuf.CodedOutputStream) {
		output.writeInt32(1, `minMapChunkX`)
		output.writeInt32(2, `minMapChunkY`)
		output.writeInt32(3, `maxMapChunkX`)
		output.writeInt32(4, `maxMapChunkY`)
	}

	def getSerializedSize = {
		import com.google.protobuf.CodedOutputStream._
		var __size = 0
		__size += computeInt32Size(1, `minMapChunkX`)
		__size += computeInt32Size(2, `minMapChunkY`)
		__size += computeInt32Size(3, `maxMapChunkX`)
		__size += computeInt32Size(4, `maxMapChunkY`)

		__size
	}

	def mergeFrom(in: com.google.protobuf.CodedInputStream, extensionRegistry: com.google.protobuf.ExtensionRegistryLite): QueryServerResponse = {
		import com.google.protobuf.ExtensionRegistryLite.{getEmptyRegistry => _emptyRegistry}
		var __minMapChunkX: Int = 0
		var __minMapChunkY: Int = 0
		var __maxMapChunkX: Int = 0
		var __maxMapChunkY: Int = 0

		def __newMerged = QueryServerResponse(
			__minMapChunkX,
			__minMapChunkY,
			__maxMapChunkX,
			__maxMapChunkY
		)
		while (true) in.readTag match {
			case 0 => return __newMerged
			case 8 => __minMapChunkX = in.readInt32()
			case 16 => __minMapChunkY = in.readInt32()
			case 24 => __maxMapChunkX = in.readInt32()
			case 32 => __maxMapChunkY = in.readInt32()
			case default => if (!in.skipField(default)) return __newMerged
		}
		null
	}

	def mergeFrom(m: QueryServerResponse) = {
		QueryServerResponse(
			m.`minMapChunkX`,
			m.`minMapChunkY`,
			m.`maxMapChunkX`,
			m.`maxMapChunkY`
		)
	}

	def getDefaultInstanceForType = QueryServerResponse.defaultInstance
	def clear = getDefaultInstanceForType
	def isInitialized = true
	def build = this
	def buildPartial = this
	def parsePartialFrom(cis: com.google.protobuf.CodedInputStream, er: com.google.protobuf.ExtensionRegistryLite) = mergeFrom(cis, er)
	override def getParserForType = this
	def newBuilderForType = getDefaultInstanceForType
	def toBuilder = this
	def toJson(indent: Int = 0): String = "ScalaBuff JSON generation not enabled. Use --generate_json_method to enable."
}

object QueryServerResponse {
	@scala.beans.BeanProperty val defaultInstance = new QueryServerResponse()

	def parseFrom(data: Array[Byte]): QueryServerResponse = defaultInstance.mergeFrom(data)
	def parseFrom(data: Array[Byte], offset: Int, length: Int): QueryServerResponse = defaultInstance.mergeFrom(data, offset, length)
	def parseFrom(byteString: com.google.protobuf.ByteString): QueryServerResponse = defaultInstance.mergeFrom(byteString)
	def parseFrom(stream: java.io.InputStream): QueryServerResponse = defaultInstance.mergeFrom(stream)
	def parseDelimitedFrom(stream: java.io.InputStream): Option[QueryServerResponse] = defaultInstance.mergeDelimitedFromStream(stream)

	val MINMAPCHUNKX_FIELD_NUMBER = 1
	val MINMAPCHUNKY_FIELD_NUMBER = 2
	val MAXMAPCHUNKX_FIELD_NUMBER = 3
	val MAXMAPCHUNKY_FIELD_NUMBER = 4

	def newBuilder = defaultInstance.newBuilderForType
	def newBuilder(prototype: QueryServerResponse) = defaultInstance.mergeFrom(prototype)

}

object CommsMessages {
	def registerAllExtensions(registry: com.google.protobuf.ExtensionRegistryLite) {
	}

	private val fromBinaryHintMap = collection.immutable.HashMap[String, Array[Byte] ⇒ com.google.protobuf.GeneratedMessageLite](
		 "Message" -> (bytes ⇒ Message.parseFrom(bytes)),
		 "Ping" -> (bytes ⇒ Ping.parseFrom(bytes)),
		 "Pong" -> (bytes ⇒ Pong.parseFrom(bytes)),
		 "Response" -> (bytes ⇒ Response.parseFrom(bytes)),
		 "NewUser" -> (bytes ⇒ NewUser.parseFrom(bytes)),
		 "Login" -> (bytes ⇒ Login.parseFrom(bytes)),
		 "Say" -> (bytes ⇒ Say.parseFrom(bytes)),
		 "MapRequestUpdates" -> (bytes ⇒ MapRequestUpdates.parseFrom(bytes)),
		 "MapIgnoreUpdates" -> (bytes ⇒ MapIgnoreUpdates.parseFrom(bytes)),
		 "Map" -> (bytes ⇒ Map.parseFrom(bytes)),
		 "QueryServer" -> (bytes ⇒ QueryServer.parseFrom(bytes)),
		 "QueryServerResponse" -> (bytes ⇒ QueryServerResponse.parseFrom(bytes))
	)

	def deserializePayload(payload: Array[Byte], payloadType: String): com.google.protobuf.GeneratedMessageLite = {
		fromBinaryHintMap.get(payloadType) match {
			case Some(f) ⇒ f(payload)
			case None    ⇒ throw new IllegalArgumentException(s"unimplemented deserialization of message payload of type [${payloadType}]")
		}
	}
}
