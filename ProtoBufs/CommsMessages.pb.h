// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CommsMessages.proto

#ifndef PROTOBUF_CommsMessages_2eproto__INCLUDED
#define PROTOBUF_CommsMessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace CommsMessages {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CommsMessages_2eproto();
void protobuf_AssignDesc_CommsMessages_2eproto();
void protobuf_ShutdownFile_CommsMessages_2eproto();

class Message;
class Ping;
class Pong;
class Response;
class Login;
class Say;
class MapRequest;
class MapIgnore;
class Map;
class MapUpdate;
class MapCharacterUpdate;
class QueryServer;
class QueryServerResponse;

enum MsgType {
  eResponse = 1,
  ePing = 2,
  ePong = 3,
  eNewUser = 4,
  eLogin = 5,
  eSay = 6,
  eMapRequest = 7,
  eMapIgnore = 8,
  eMap = 9,
  eMapUpdate = 10,
  eMapCharacterUpdate = 11,
  eQueryServer = 12,
  eQueryServerResponse = 13
};
bool MsgType_IsValid(int value);
const MsgType MsgType_MIN = eResponse;
const MsgType MsgType_MAX = eQueryServerResponse;
const int MsgType_ARRAYSIZE = MsgType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MsgType_descriptor();
inline const ::std::string& MsgType_Name(MsgType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgType_descriptor(), value);
}
inline bool MsgType_Parse(
    const ::std::string& name, MsgType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgType>(
    MsgType_descriptor(), name, value);
}
// ===================================================================

class Message : public ::google::protobuf::Message {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  void Swap(Message* other);

  // implements Message ----------------------------------------------

  Message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 msgtype = 1;
  inline bool has_msgtype() const;
  inline void clear_msgtype();
  static const int kMsgtypeFieldNumber = 1;
  inline ::google::protobuf::int32 msgtype() const;
  inline void set_msgtype(::google::protobuf::int32 value);

  // required int32 from = 2;
  inline bool has_from() const;
  inline void clear_from();
  static const int kFromFieldNumber = 2;
  inline ::google::protobuf::int32 from() const;
  inline void set_from(::google::protobuf::int32 value);

  // required int32 dest = 3;
  inline bool has_dest() const;
  inline void clear_dest();
  static const int kDestFieldNumber = 3;
  inline ::google::protobuf::int32 dest() const;
  inline void set_dest(::google::protobuf::int32 value);

  // optional .CommsMessages.Response response = 4;
  inline bool has_response() const;
  inline void clear_response();
  static const int kResponseFieldNumber = 4;
  inline const ::CommsMessages::Response& response() const;
  inline ::CommsMessages::Response* mutable_response();
  inline ::CommsMessages::Response* release_response();
  inline void set_allocated_response(::CommsMessages::Response* response);

  // optional .CommsMessages.Ping ping = 5;
  inline bool has_ping() const;
  inline void clear_ping();
  static const int kPingFieldNumber = 5;
  inline const ::CommsMessages::Ping& ping() const;
  inline ::CommsMessages::Ping* mutable_ping();
  inline ::CommsMessages::Ping* release_ping();
  inline void set_allocated_ping(::CommsMessages::Ping* ping);

  // optional .CommsMessages.Pong pong = 6;
  inline bool has_pong() const;
  inline void clear_pong();
  static const int kPongFieldNumber = 6;
  inline const ::CommsMessages::Pong& pong() const;
  inline ::CommsMessages::Pong* mutable_pong();
  inline ::CommsMessages::Pong* release_pong();
  inline void set_allocated_pong(::CommsMessages::Pong* pong);

  // optional .CommsMessages.Login login = 7;
  inline bool has_login() const;
  inline void clear_login();
  static const int kLoginFieldNumber = 7;
  inline const ::CommsMessages::Login& login() const;
  inline ::CommsMessages::Login* mutable_login();
  inline ::CommsMessages::Login* release_login();
  inline void set_allocated_login(::CommsMessages::Login* login);

  // optional .CommsMessages.Say say = 8;
  inline bool has_say() const;
  inline void clear_say();
  static const int kSayFieldNumber = 8;
  inline const ::CommsMessages::Say& say() const;
  inline ::CommsMessages::Say* mutable_say();
  inline ::CommsMessages::Say* release_say();
  inline void set_allocated_say(::CommsMessages::Say* say);

  // optional .CommsMessages.MapRequest mapRequest = 9;
  inline bool has_maprequest() const;
  inline void clear_maprequest();
  static const int kMapRequestFieldNumber = 9;
  inline const ::CommsMessages::MapRequest& maprequest() const;
  inline ::CommsMessages::MapRequest* mutable_maprequest();
  inline ::CommsMessages::MapRequest* release_maprequest();
  inline void set_allocated_maprequest(::CommsMessages::MapRequest* maprequest);

  // optional .CommsMessages.MapIgnore mapIgnore = 10;
  inline bool has_mapignore() const;
  inline void clear_mapignore();
  static const int kMapIgnoreFieldNumber = 10;
  inline const ::CommsMessages::MapIgnore& mapignore() const;
  inline ::CommsMessages::MapIgnore* mutable_mapignore();
  inline ::CommsMessages::MapIgnore* release_mapignore();
  inline void set_allocated_mapignore(::CommsMessages::MapIgnore* mapignore);

  // optional .CommsMessages.Map map = 11;
  inline bool has_map() const;
  inline void clear_map();
  static const int kMapFieldNumber = 11;
  inline const ::CommsMessages::Map& map() const;
  inline ::CommsMessages::Map* mutable_map();
  inline ::CommsMessages::Map* release_map();
  inline void set_allocated_map(::CommsMessages::Map* map);

  // optional .CommsMessages.MapUpdate mapUpdate = 12;
  inline bool has_mapupdate() const;
  inline void clear_mapupdate();
  static const int kMapUpdateFieldNumber = 12;
  inline const ::CommsMessages::MapUpdate& mapupdate() const;
  inline ::CommsMessages::MapUpdate* mutable_mapupdate();
  inline ::CommsMessages::MapUpdate* release_mapupdate();
  inline void set_allocated_mapupdate(::CommsMessages::MapUpdate* mapupdate);

  // optional .CommsMessages.MapCharacterUpdate mapCharacterUpdate = 13;
  inline bool has_mapcharacterupdate() const;
  inline void clear_mapcharacterupdate();
  static const int kMapCharacterUpdateFieldNumber = 13;
  inline const ::CommsMessages::MapCharacterUpdate& mapcharacterupdate() const;
  inline ::CommsMessages::MapCharacterUpdate* mutable_mapcharacterupdate();
  inline ::CommsMessages::MapCharacterUpdate* release_mapcharacterupdate();
  inline void set_allocated_mapcharacterupdate(::CommsMessages::MapCharacterUpdate* mapcharacterupdate);

  // optional .CommsMessages.QueryServer queryServer = 14;
  inline bool has_queryserver() const;
  inline void clear_queryserver();
  static const int kQueryServerFieldNumber = 14;
  inline const ::CommsMessages::QueryServer& queryserver() const;
  inline ::CommsMessages::QueryServer* mutable_queryserver();
  inline ::CommsMessages::QueryServer* release_queryserver();
  inline void set_allocated_queryserver(::CommsMessages::QueryServer* queryserver);

  // optional .CommsMessages.QueryServerResponse queryServerResponse = 15;
  inline bool has_queryserverresponse() const;
  inline void clear_queryserverresponse();
  static const int kQueryServerResponseFieldNumber = 15;
  inline const ::CommsMessages::QueryServerResponse& queryserverresponse() const;
  inline ::CommsMessages::QueryServerResponse* mutable_queryserverresponse();
  inline ::CommsMessages::QueryServerResponse* release_queryserverresponse();
  inline void set_allocated_queryserverresponse(::CommsMessages::QueryServerResponse* queryserverresponse);

  // @@protoc_insertion_point(class_scope:CommsMessages.Message)
 private:
  inline void set_has_msgtype();
  inline void clear_has_msgtype();
  inline void set_has_from();
  inline void clear_has_from();
  inline void set_has_dest();
  inline void clear_has_dest();
  inline void set_has_response();
  inline void clear_has_response();
  inline void set_has_ping();
  inline void clear_has_ping();
  inline void set_has_pong();
  inline void clear_has_pong();
  inline void set_has_login();
  inline void clear_has_login();
  inline void set_has_say();
  inline void clear_has_say();
  inline void set_has_maprequest();
  inline void clear_has_maprequest();
  inline void set_has_mapignore();
  inline void clear_has_mapignore();
  inline void set_has_map();
  inline void clear_has_map();
  inline void set_has_mapupdate();
  inline void clear_has_mapupdate();
  inline void set_has_mapcharacterupdate();
  inline void clear_has_mapcharacterupdate();
  inline void set_has_queryserver();
  inline void clear_has_queryserver();
  inline void set_has_queryserverresponse();
  inline void clear_has_queryserverresponse();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 msgtype_;
  ::google::protobuf::int32 from_;
  ::CommsMessages::Response* response_;
  ::CommsMessages::Ping* ping_;
  ::CommsMessages::Pong* pong_;
  ::CommsMessages::Login* login_;
  ::CommsMessages::Say* say_;
  ::CommsMessages::MapRequest* maprequest_;
  ::CommsMessages::MapIgnore* mapignore_;
  ::CommsMessages::Map* map_;
  ::CommsMessages::MapUpdate* mapupdate_;
  ::CommsMessages::MapCharacterUpdate* mapcharacterupdate_;
  ::CommsMessages::QueryServer* queryserver_;
  ::CommsMessages::QueryServerResponse* queryserverresponse_;
  ::google::protobuf::int32 dest_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  friend void  protobuf_AddDesc_CommsMessages_2eproto();
  friend void protobuf_AssignDesc_CommsMessages_2eproto();
  friend void protobuf_ShutdownFile_CommsMessages_2eproto();

  void InitAsDefaultInstance();
  static Message* default_instance_;
};
// -------------------------------------------------------------------

class Ping : public ::google::protobuf::Message {
 public:
  Ping();
  virtual ~Ping();

  Ping(const Ping& from);

  inline Ping& operator=(const Ping& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ping& default_instance();

  void Swap(Ping* other);

  // implements Message ----------------------------------------------

  Ping* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Ping& from);
  void MergeFrom(const Ping& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CommsMessages.Ping)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_CommsMessages_2eproto();
  friend void protobuf_AssignDesc_CommsMessages_2eproto();
  friend void protobuf_ShutdownFile_CommsMessages_2eproto();

  void InitAsDefaultInstance();
  static Ping* default_instance_;
};
// -------------------------------------------------------------------

class Pong : public ::google::protobuf::Message {
 public:
  Pong();
  virtual ~Pong();

  Pong(const Pong& from);

  inline Pong& operator=(const Pong& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pong& default_instance();

  void Swap(Pong* other);

  // implements Message ----------------------------------------------

  Pong* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Pong& from);
  void MergeFrom(const Pong& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CommsMessages.Pong)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_CommsMessages_2eproto();
  friend void protobuf_AssignDesc_CommsMessages_2eproto();
  friend void protobuf_ShutdownFile_CommsMessages_2eproto();

  void InitAsDefaultInstance();
  static Pong* default_instance_;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  void Swap(Response* other);

  // implements Message ----------------------------------------------

  Response* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // optional string message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:CommsMessages.Response)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* message_;
  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CommsMessages_2eproto();
  friend void protobuf_AssignDesc_CommsMessages_2eproto();
  friend void protobuf_ShutdownFile_CommsMessages_2eproto();

  void InitAsDefaultInstance();
  static Response* default_instance_;
};
// -------------------------------------------------------------------

class Login : public ::google::protobuf::Message {
 public:
  Login();
  virtual ~Login();

  Login(const Login& from);

  inline Login& operator=(const Login& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Login& default_instance();

  void Swap(Login* other);

  // implements Message ----------------------------------------------

  Login* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Login& from);
  void MergeFrom(const Login& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ipaddress = 1;
  inline bool has_ipaddress() const;
  inline void clear_ipaddress();
  static const int kIpaddressFieldNumber = 1;
  inline const ::std::string& ipaddress() const;
  inline void set_ipaddress(const ::std::string& value);
  inline void set_ipaddress(const char* value);
  inline void set_ipaddress(const char* value, size_t size);
  inline ::std::string* mutable_ipaddress();
  inline ::std::string* release_ipaddress();
  inline void set_allocated_ipaddress(::std::string* ipaddress);

  // required int32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // required string username = 3;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 3;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // required string password = 4;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 4;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:CommsMessages.Login)
 private:
  inline void set_has_ipaddress();
  inline void clear_has_ipaddress();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* ipaddress_;
  ::std::string* username_;
  ::std::string* password_;
  ::google::protobuf::int32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_CommsMessages_2eproto();
  friend void protobuf_AssignDesc_CommsMessages_2eproto();
  friend void protobuf_ShutdownFile_CommsMessages_2eproto();

  void InitAsDefaultInstance();
  static Login* default_instance_;
};
// -------------------------------------------------------------------

class Say : public ::google::protobuf::Message {
 public:
  Say();
  virtual ~Say();

  Say(const Say& from);

  inline Say& operator=(const Say& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Say& default_instance();

  void Swap(Say* other);

  // implements Message ----------------------------------------------

  Say* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Say& from);
  void MergeFrom(const Say& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string text = 1;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 1;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:CommsMessages.Say)
 private:
  inline void set_has_text();
  inline void clear_has_text();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* text_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CommsMessages_2eproto();
  friend void protobuf_AssignDesc_CommsMessages_2eproto();
  friend void protobuf_ShutdownFile_CommsMessages_2eproto();

  void InitAsDefaultInstance();
  static Say* default_instance_;
};
// -------------------------------------------------------------------

class MapRequest : public ::google::protobuf::Message {
 public:
  MapRequest();
  virtual ~MapRequest();

  MapRequest(const MapRequest& from);

  inline MapRequest& operator=(const MapRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapRequest& default_instance();

  void Swap(MapRequest* other);

  // implements Message ----------------------------------------------

  MapRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapRequest& from);
  void MergeFrom(const MapRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // required int32 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CommsMessages.MapRequest)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CommsMessages_2eproto();
  friend void protobuf_AssignDesc_CommsMessages_2eproto();
  friend void protobuf_ShutdownFile_CommsMessages_2eproto();

  void InitAsDefaultInstance();
  static MapRequest* default_instance_;
};
// -------------------------------------------------------------------

class MapIgnore : public ::google::protobuf::Message {
 public:
  MapIgnore();
  virtual ~MapIgnore();

  MapIgnore(const MapIgnore& from);

  inline MapIgnore& operator=(const MapIgnore& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapIgnore& default_instance();

  void Swap(MapIgnore* other);

  // implements Message ----------------------------------------------

  MapIgnore* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapIgnore& from);
  void MergeFrom(const MapIgnore& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // required int32 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CommsMessages.MapIgnore)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CommsMessages_2eproto();
  friend void protobuf_AssignDesc_CommsMessages_2eproto();
  friend void protobuf_ShutdownFile_CommsMessages_2eproto();

  void InitAsDefaultInstance();
  static MapIgnore* default_instance_;
};
// -------------------------------------------------------------------

class Map : public ::google::protobuf::Message {
 public:
  Map();
  virtual ~Map();

  Map(const Map& from);

  inline Map& operator=(const Map& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Map& default_instance();

  void Swap(Map* other);

  // implements Message ----------------------------------------------

  Map* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Map& from);
  void MergeFrom(const Map& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 minX = 1;
  inline bool has_minx() const;
  inline void clear_minx();
  static const int kMinXFieldNumber = 1;
  inline ::google::protobuf::int32 minx() const;
  inline void set_minx(::google::protobuf::int32 value);

  // required int32 minY = 2;
  inline bool has_miny() const;
  inline void clear_miny();
  static const int kMinYFieldNumber = 2;
  inline ::google::protobuf::int32 miny() const;
  inline void set_miny(::google::protobuf::int32 value);

  // required int32 maxX = 3;
  inline bool has_maxx() const;
  inline void clear_maxx();
  static const int kMaxXFieldNumber = 3;
  inline ::google::protobuf::int32 maxx() const;
  inline void set_maxx(::google::protobuf::int32 value);

  // required int32 maxY = 4;
  inline bool has_maxy() const;
  inline void clear_maxy();
  static const int kMaxYFieldNumber = 4;
  inline ::google::protobuf::int32 maxy() const;
  inline void set_maxy(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CommsMessages.Map)
 private:
  inline void set_has_minx();
  inline void clear_has_minx();
  inline void set_has_miny();
  inline void clear_has_miny();
  inline void set_has_maxx();
  inline void clear_has_maxx();
  inline void set_has_maxy();
  inline void clear_has_maxy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 minx_;
  ::google::protobuf::int32 miny_;
  ::google::protobuf::int32 maxx_;
  ::google::protobuf::int32 maxy_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_CommsMessages_2eproto();
  friend void protobuf_AssignDesc_CommsMessages_2eproto();
  friend void protobuf_ShutdownFile_CommsMessages_2eproto();

  void InitAsDefaultInstance();
  static Map* default_instance_;
};
// -------------------------------------------------------------------

class MapUpdate : public ::google::protobuf::Message {
 public:
  MapUpdate();
  virtual ~MapUpdate();

  MapUpdate(const MapUpdate& from);

  inline MapUpdate& operator=(const MapUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapUpdate& default_instance();

  void Swap(MapUpdate* other);

  // implements Message ----------------------------------------------

  MapUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapUpdate& from);
  void MergeFrom(const MapUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // required int32 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // required int32 z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline ::google::protobuf::int32 z() const;
  inline void set_z(::google::protobuf::int32 value);

  // required int32 newBlock = 4;
  inline bool has_newblock() const;
  inline void clear_newblock();
  static const int kNewBlockFieldNumber = 4;
  inline ::google::protobuf::int32 newblock() const;
  inline void set_newblock(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CommsMessages.MapUpdate)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  inline void set_has_newblock();
  inline void clear_has_newblock();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 z_;
  ::google::protobuf::int32 newblock_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_CommsMessages_2eproto();
  friend void protobuf_AssignDesc_CommsMessages_2eproto();
  friend void protobuf_ShutdownFile_CommsMessages_2eproto();

  void InitAsDefaultInstance();
  static MapUpdate* default_instance_;
};
// -------------------------------------------------------------------

class MapCharacterUpdate : public ::google::protobuf::Message {
 public:
  MapCharacterUpdate();
  virtual ~MapCharacterUpdate();

  MapCharacterUpdate(const MapCharacterUpdate& from);

  inline MapCharacterUpdate& operator=(const MapCharacterUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapCharacterUpdate& default_instance();

  void Swap(MapCharacterUpdate* other);

  // implements Message ----------------------------------------------

  MapCharacterUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapCharacterUpdate& from);
  void MergeFrom(const MapCharacterUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required int32 x = 2;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 2;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // required int32 y = 3;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 3;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // required int32 z = 4;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 4;
  inline ::google::protobuf::int32 z() const;
  inline void set_z(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CommsMessages.MapCharacterUpdate)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 z_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_CommsMessages_2eproto();
  friend void protobuf_AssignDesc_CommsMessages_2eproto();
  friend void protobuf_ShutdownFile_CommsMessages_2eproto();

  void InitAsDefaultInstance();
  static MapCharacterUpdate* default_instance_;
};
// -------------------------------------------------------------------

class QueryServer : public ::google::protobuf::Message {
 public:
  QueryServer();
  virtual ~QueryServer();

  QueryServer(const QueryServer& from);

  inline QueryServer& operator=(const QueryServer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryServer& default_instance();

  void Swap(QueryServer* other);

  // implements Message ----------------------------------------------

  QueryServer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryServer& from);
  void MergeFrom(const QueryServer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string parameter = 1;
  inline bool has_parameter() const;
  inline void clear_parameter();
  static const int kParameterFieldNumber = 1;
  inline const ::std::string& parameter() const;
  inline void set_parameter(const ::std::string& value);
  inline void set_parameter(const char* value);
  inline void set_parameter(const char* value, size_t size);
  inline ::std::string* mutable_parameter();
  inline ::std::string* release_parameter();
  inline void set_allocated_parameter(::std::string* parameter);

  // @@protoc_insertion_point(class_scope:CommsMessages.QueryServer)
 private:
  inline void set_has_parameter();
  inline void clear_has_parameter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* parameter_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CommsMessages_2eproto();
  friend void protobuf_AssignDesc_CommsMessages_2eproto();
  friend void protobuf_ShutdownFile_CommsMessages_2eproto();

  void InitAsDefaultInstance();
  static QueryServer* default_instance_;
};
// -------------------------------------------------------------------

class QueryServerResponse : public ::google::protobuf::Message {
 public:
  QueryServerResponse();
  virtual ~QueryServerResponse();

  QueryServerResponse(const QueryServerResponse& from);

  inline QueryServerResponse& operator=(const QueryServerResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryServerResponse& default_instance();

  void Swap(QueryServerResponse* other);

  // implements Message ----------------------------------------------

  QueryServerResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryServerResponse& from);
  void MergeFrom(const QueryServerResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string parameter = 1;
  inline bool has_parameter() const;
  inline void clear_parameter();
  static const int kParameterFieldNumber = 1;
  inline const ::std::string& parameter() const;
  inline void set_parameter(const ::std::string& value);
  inline void set_parameter(const char* value);
  inline void set_parameter(const char* value, size_t size);
  inline ::std::string* mutable_parameter();
  inline ::std::string* release_parameter();
  inline void set_allocated_parameter(::std::string* parameter);

  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:CommsMessages.QueryServerResponse)
 private:
  inline void set_has_parameter();
  inline void clear_has_parameter();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* parameter_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CommsMessages_2eproto();
  friend void protobuf_AssignDesc_CommsMessages_2eproto();
  friend void protobuf_ShutdownFile_CommsMessages_2eproto();

  void InitAsDefaultInstance();
  static QueryServerResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// Message

// required int32 msgtype = 1;
inline bool Message::has_msgtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message::set_has_msgtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message::clear_has_msgtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message::clear_msgtype() {
  msgtype_ = 0;
  clear_has_msgtype();
}
inline ::google::protobuf::int32 Message::msgtype() const {
  return msgtype_;
}
inline void Message::set_msgtype(::google::protobuf::int32 value) {
  set_has_msgtype();
  msgtype_ = value;
}

// required int32 from = 2;
inline bool Message::has_from() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message::set_has_from() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message::clear_has_from() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message::clear_from() {
  from_ = 0;
  clear_has_from();
}
inline ::google::protobuf::int32 Message::from() const {
  return from_;
}
inline void Message::set_from(::google::protobuf::int32 value) {
  set_has_from();
  from_ = value;
}

// required int32 dest = 3;
inline bool Message::has_dest() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Message::set_has_dest() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Message::clear_has_dest() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Message::clear_dest() {
  dest_ = 0;
  clear_has_dest();
}
inline ::google::protobuf::int32 Message::dest() const {
  return dest_;
}
inline void Message::set_dest(::google::protobuf::int32 value) {
  set_has_dest();
  dest_ = value;
}

// optional .CommsMessages.Response response = 4;
inline bool Message::has_response() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Message::set_has_response() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Message::clear_has_response() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Message::clear_response() {
  if (response_ != NULL) response_->::CommsMessages::Response::Clear();
  clear_has_response();
}
inline const ::CommsMessages::Response& Message::response() const {
  return response_ != NULL ? *response_ : *default_instance_->response_;
}
inline ::CommsMessages::Response* Message::mutable_response() {
  set_has_response();
  if (response_ == NULL) response_ = new ::CommsMessages::Response;
  return response_;
}
inline ::CommsMessages::Response* Message::release_response() {
  clear_has_response();
  ::CommsMessages::Response* temp = response_;
  response_ = NULL;
  return temp;
}
inline void Message::set_allocated_response(::CommsMessages::Response* response) {
  delete response_;
  response_ = response;
  if (response) {
    set_has_response();
  } else {
    clear_has_response();
  }
}

// optional .CommsMessages.Ping ping = 5;
inline bool Message::has_ping() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Message::set_has_ping() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Message::clear_has_ping() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Message::clear_ping() {
  if (ping_ != NULL) ping_->::CommsMessages::Ping::Clear();
  clear_has_ping();
}
inline const ::CommsMessages::Ping& Message::ping() const {
  return ping_ != NULL ? *ping_ : *default_instance_->ping_;
}
inline ::CommsMessages::Ping* Message::mutable_ping() {
  set_has_ping();
  if (ping_ == NULL) ping_ = new ::CommsMessages::Ping;
  return ping_;
}
inline ::CommsMessages::Ping* Message::release_ping() {
  clear_has_ping();
  ::CommsMessages::Ping* temp = ping_;
  ping_ = NULL;
  return temp;
}
inline void Message::set_allocated_ping(::CommsMessages::Ping* ping) {
  delete ping_;
  ping_ = ping;
  if (ping) {
    set_has_ping();
  } else {
    clear_has_ping();
  }
}

// optional .CommsMessages.Pong pong = 6;
inline bool Message::has_pong() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Message::set_has_pong() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Message::clear_has_pong() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Message::clear_pong() {
  if (pong_ != NULL) pong_->::CommsMessages::Pong::Clear();
  clear_has_pong();
}
inline const ::CommsMessages::Pong& Message::pong() const {
  return pong_ != NULL ? *pong_ : *default_instance_->pong_;
}
inline ::CommsMessages::Pong* Message::mutable_pong() {
  set_has_pong();
  if (pong_ == NULL) pong_ = new ::CommsMessages::Pong;
  return pong_;
}
inline ::CommsMessages::Pong* Message::release_pong() {
  clear_has_pong();
  ::CommsMessages::Pong* temp = pong_;
  pong_ = NULL;
  return temp;
}
inline void Message::set_allocated_pong(::CommsMessages::Pong* pong) {
  delete pong_;
  pong_ = pong;
  if (pong) {
    set_has_pong();
  } else {
    clear_has_pong();
  }
}

// optional .CommsMessages.Login login = 7;
inline bool Message::has_login() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Message::set_has_login() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Message::clear_has_login() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Message::clear_login() {
  if (login_ != NULL) login_->::CommsMessages::Login::Clear();
  clear_has_login();
}
inline const ::CommsMessages::Login& Message::login() const {
  return login_ != NULL ? *login_ : *default_instance_->login_;
}
inline ::CommsMessages::Login* Message::mutable_login() {
  set_has_login();
  if (login_ == NULL) login_ = new ::CommsMessages::Login;
  return login_;
}
inline ::CommsMessages::Login* Message::release_login() {
  clear_has_login();
  ::CommsMessages::Login* temp = login_;
  login_ = NULL;
  return temp;
}
inline void Message::set_allocated_login(::CommsMessages::Login* login) {
  delete login_;
  login_ = login;
  if (login) {
    set_has_login();
  } else {
    clear_has_login();
  }
}

// optional .CommsMessages.Say say = 8;
inline bool Message::has_say() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Message::set_has_say() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Message::clear_has_say() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Message::clear_say() {
  if (say_ != NULL) say_->::CommsMessages::Say::Clear();
  clear_has_say();
}
inline const ::CommsMessages::Say& Message::say() const {
  return say_ != NULL ? *say_ : *default_instance_->say_;
}
inline ::CommsMessages::Say* Message::mutable_say() {
  set_has_say();
  if (say_ == NULL) say_ = new ::CommsMessages::Say;
  return say_;
}
inline ::CommsMessages::Say* Message::release_say() {
  clear_has_say();
  ::CommsMessages::Say* temp = say_;
  say_ = NULL;
  return temp;
}
inline void Message::set_allocated_say(::CommsMessages::Say* say) {
  delete say_;
  say_ = say;
  if (say) {
    set_has_say();
  } else {
    clear_has_say();
  }
}

// optional .CommsMessages.MapRequest mapRequest = 9;
inline bool Message::has_maprequest() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Message::set_has_maprequest() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Message::clear_has_maprequest() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Message::clear_maprequest() {
  if (maprequest_ != NULL) maprequest_->::CommsMessages::MapRequest::Clear();
  clear_has_maprequest();
}
inline const ::CommsMessages::MapRequest& Message::maprequest() const {
  return maprequest_ != NULL ? *maprequest_ : *default_instance_->maprequest_;
}
inline ::CommsMessages::MapRequest* Message::mutable_maprequest() {
  set_has_maprequest();
  if (maprequest_ == NULL) maprequest_ = new ::CommsMessages::MapRequest;
  return maprequest_;
}
inline ::CommsMessages::MapRequest* Message::release_maprequest() {
  clear_has_maprequest();
  ::CommsMessages::MapRequest* temp = maprequest_;
  maprequest_ = NULL;
  return temp;
}
inline void Message::set_allocated_maprequest(::CommsMessages::MapRequest* maprequest) {
  delete maprequest_;
  maprequest_ = maprequest;
  if (maprequest) {
    set_has_maprequest();
  } else {
    clear_has_maprequest();
  }
}

// optional .CommsMessages.MapIgnore mapIgnore = 10;
inline bool Message::has_mapignore() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Message::set_has_mapignore() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Message::clear_has_mapignore() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Message::clear_mapignore() {
  if (mapignore_ != NULL) mapignore_->::CommsMessages::MapIgnore::Clear();
  clear_has_mapignore();
}
inline const ::CommsMessages::MapIgnore& Message::mapignore() const {
  return mapignore_ != NULL ? *mapignore_ : *default_instance_->mapignore_;
}
inline ::CommsMessages::MapIgnore* Message::mutable_mapignore() {
  set_has_mapignore();
  if (mapignore_ == NULL) mapignore_ = new ::CommsMessages::MapIgnore;
  return mapignore_;
}
inline ::CommsMessages::MapIgnore* Message::release_mapignore() {
  clear_has_mapignore();
  ::CommsMessages::MapIgnore* temp = mapignore_;
  mapignore_ = NULL;
  return temp;
}
inline void Message::set_allocated_mapignore(::CommsMessages::MapIgnore* mapignore) {
  delete mapignore_;
  mapignore_ = mapignore;
  if (mapignore) {
    set_has_mapignore();
  } else {
    clear_has_mapignore();
  }
}

// optional .CommsMessages.Map map = 11;
inline bool Message::has_map() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Message::set_has_map() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Message::clear_has_map() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Message::clear_map() {
  if (map_ != NULL) map_->::CommsMessages::Map::Clear();
  clear_has_map();
}
inline const ::CommsMessages::Map& Message::map() const {
  return map_ != NULL ? *map_ : *default_instance_->map_;
}
inline ::CommsMessages::Map* Message::mutable_map() {
  set_has_map();
  if (map_ == NULL) map_ = new ::CommsMessages::Map;
  return map_;
}
inline ::CommsMessages::Map* Message::release_map() {
  clear_has_map();
  ::CommsMessages::Map* temp = map_;
  map_ = NULL;
  return temp;
}
inline void Message::set_allocated_map(::CommsMessages::Map* map) {
  delete map_;
  map_ = map;
  if (map) {
    set_has_map();
  } else {
    clear_has_map();
  }
}

// optional .CommsMessages.MapUpdate mapUpdate = 12;
inline bool Message::has_mapupdate() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Message::set_has_mapupdate() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Message::clear_has_mapupdate() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Message::clear_mapupdate() {
  if (mapupdate_ != NULL) mapupdate_->::CommsMessages::MapUpdate::Clear();
  clear_has_mapupdate();
}
inline const ::CommsMessages::MapUpdate& Message::mapupdate() const {
  return mapupdate_ != NULL ? *mapupdate_ : *default_instance_->mapupdate_;
}
inline ::CommsMessages::MapUpdate* Message::mutable_mapupdate() {
  set_has_mapupdate();
  if (mapupdate_ == NULL) mapupdate_ = new ::CommsMessages::MapUpdate;
  return mapupdate_;
}
inline ::CommsMessages::MapUpdate* Message::release_mapupdate() {
  clear_has_mapupdate();
  ::CommsMessages::MapUpdate* temp = mapupdate_;
  mapupdate_ = NULL;
  return temp;
}
inline void Message::set_allocated_mapupdate(::CommsMessages::MapUpdate* mapupdate) {
  delete mapupdate_;
  mapupdate_ = mapupdate;
  if (mapupdate) {
    set_has_mapupdate();
  } else {
    clear_has_mapupdate();
  }
}

// optional .CommsMessages.MapCharacterUpdate mapCharacterUpdate = 13;
inline bool Message::has_mapcharacterupdate() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Message::set_has_mapcharacterupdate() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Message::clear_has_mapcharacterupdate() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Message::clear_mapcharacterupdate() {
  if (mapcharacterupdate_ != NULL) mapcharacterupdate_->::CommsMessages::MapCharacterUpdate::Clear();
  clear_has_mapcharacterupdate();
}
inline const ::CommsMessages::MapCharacterUpdate& Message::mapcharacterupdate() const {
  return mapcharacterupdate_ != NULL ? *mapcharacterupdate_ : *default_instance_->mapcharacterupdate_;
}
inline ::CommsMessages::MapCharacterUpdate* Message::mutable_mapcharacterupdate() {
  set_has_mapcharacterupdate();
  if (mapcharacterupdate_ == NULL) mapcharacterupdate_ = new ::CommsMessages::MapCharacterUpdate;
  return mapcharacterupdate_;
}
inline ::CommsMessages::MapCharacterUpdate* Message::release_mapcharacterupdate() {
  clear_has_mapcharacterupdate();
  ::CommsMessages::MapCharacterUpdate* temp = mapcharacterupdate_;
  mapcharacterupdate_ = NULL;
  return temp;
}
inline void Message::set_allocated_mapcharacterupdate(::CommsMessages::MapCharacterUpdate* mapcharacterupdate) {
  delete mapcharacterupdate_;
  mapcharacterupdate_ = mapcharacterupdate;
  if (mapcharacterupdate) {
    set_has_mapcharacterupdate();
  } else {
    clear_has_mapcharacterupdate();
  }
}

// optional .CommsMessages.QueryServer queryServer = 14;
inline bool Message::has_queryserver() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Message::set_has_queryserver() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Message::clear_has_queryserver() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Message::clear_queryserver() {
  if (queryserver_ != NULL) queryserver_->::CommsMessages::QueryServer::Clear();
  clear_has_queryserver();
}
inline const ::CommsMessages::QueryServer& Message::queryserver() const {
  return queryserver_ != NULL ? *queryserver_ : *default_instance_->queryserver_;
}
inline ::CommsMessages::QueryServer* Message::mutable_queryserver() {
  set_has_queryserver();
  if (queryserver_ == NULL) queryserver_ = new ::CommsMessages::QueryServer;
  return queryserver_;
}
inline ::CommsMessages::QueryServer* Message::release_queryserver() {
  clear_has_queryserver();
  ::CommsMessages::QueryServer* temp = queryserver_;
  queryserver_ = NULL;
  return temp;
}
inline void Message::set_allocated_queryserver(::CommsMessages::QueryServer* queryserver) {
  delete queryserver_;
  queryserver_ = queryserver;
  if (queryserver) {
    set_has_queryserver();
  } else {
    clear_has_queryserver();
  }
}

// optional .CommsMessages.QueryServerResponse queryServerResponse = 15;
inline bool Message::has_queryserverresponse() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Message::set_has_queryserverresponse() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Message::clear_has_queryserverresponse() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Message::clear_queryserverresponse() {
  if (queryserverresponse_ != NULL) queryserverresponse_->::CommsMessages::QueryServerResponse::Clear();
  clear_has_queryserverresponse();
}
inline const ::CommsMessages::QueryServerResponse& Message::queryserverresponse() const {
  return queryserverresponse_ != NULL ? *queryserverresponse_ : *default_instance_->queryserverresponse_;
}
inline ::CommsMessages::QueryServerResponse* Message::mutable_queryserverresponse() {
  set_has_queryserverresponse();
  if (queryserverresponse_ == NULL) queryserverresponse_ = new ::CommsMessages::QueryServerResponse;
  return queryserverresponse_;
}
inline ::CommsMessages::QueryServerResponse* Message::release_queryserverresponse() {
  clear_has_queryserverresponse();
  ::CommsMessages::QueryServerResponse* temp = queryserverresponse_;
  queryserverresponse_ = NULL;
  return temp;
}
inline void Message::set_allocated_queryserverresponse(::CommsMessages::QueryServerResponse* queryserverresponse) {
  delete queryserverresponse_;
  queryserverresponse_ = queryserverresponse;
  if (queryserverresponse) {
    set_has_queryserverresponse();
  } else {
    clear_has_queryserverresponse();
  }
}

// -------------------------------------------------------------------

// Ping

// -------------------------------------------------------------------

// Pong

// -------------------------------------------------------------------

// Response

// required int32 code = 1;
inline bool Response::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 Response::code() const {
  return code_;
}
inline void Response::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// optional string message = 2;
inline bool Response::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& Response::message() const {
  return *message_;
}
inline void Response::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void Response::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void Response::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Response::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* Response::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Response::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Login

// required string ipaddress = 1;
inline bool Login::has_ipaddress() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Login::set_has_ipaddress() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Login::clear_has_ipaddress() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Login::clear_ipaddress() {
  if (ipaddress_ != &::google::protobuf::internal::kEmptyString) {
    ipaddress_->clear();
  }
  clear_has_ipaddress();
}
inline const ::std::string& Login::ipaddress() const {
  return *ipaddress_;
}
inline void Login::set_ipaddress(const ::std::string& value) {
  set_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::kEmptyString) {
    ipaddress_ = new ::std::string;
  }
  ipaddress_->assign(value);
}
inline void Login::set_ipaddress(const char* value) {
  set_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::kEmptyString) {
    ipaddress_ = new ::std::string;
  }
  ipaddress_->assign(value);
}
inline void Login::set_ipaddress(const char* value, size_t size) {
  set_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::kEmptyString) {
    ipaddress_ = new ::std::string;
  }
  ipaddress_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Login::mutable_ipaddress() {
  set_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::kEmptyString) {
    ipaddress_ = new ::std::string;
  }
  return ipaddress_;
}
inline ::std::string* Login::release_ipaddress() {
  clear_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ipaddress_;
    ipaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Login::set_allocated_ipaddress(::std::string* ipaddress) {
  if (ipaddress_ != &::google::protobuf::internal::kEmptyString) {
    delete ipaddress_;
  }
  if (ipaddress) {
    set_has_ipaddress();
    ipaddress_ = ipaddress;
  } else {
    clear_has_ipaddress();
    ipaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 port = 2;
inline bool Login::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Login::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Login::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Login::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 Login::port() const {
  return port_;
}
inline void Login::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// required string username = 3;
inline bool Login::has_username() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Login::set_has_username() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Login::clear_has_username() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Login::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& Login::username() const {
  return *username_;
}
inline void Login::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void Login::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void Login::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Login::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* Login::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Login::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string password = 4;
inline bool Login::has_password() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Login::set_has_password() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Login::clear_has_password() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Login::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& Login::password() const {
  return *password_;
}
inline void Login::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void Login::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void Login::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Login::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* Login::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Login::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Say

// required string text = 1;
inline bool Say::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Say::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Say::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Say::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& Say::text() const {
  return *text_;
}
inline void Say::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void Say::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void Say::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Say::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* Say::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Say::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MapRequest

// required int32 x = 1;
inline bool MapRequest::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapRequest::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapRequest::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapRequest::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 MapRequest::x() const {
  return x_;
}
inline void MapRequest::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// required int32 y = 2;
inline bool MapRequest::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapRequest::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapRequest::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapRequest::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 MapRequest::y() const {
  return y_;
}
inline void MapRequest::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// -------------------------------------------------------------------

// MapIgnore

// required int32 x = 1;
inline bool MapIgnore::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapIgnore::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapIgnore::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapIgnore::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 MapIgnore::x() const {
  return x_;
}
inline void MapIgnore::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// required int32 y = 2;
inline bool MapIgnore::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapIgnore::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapIgnore::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapIgnore::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 MapIgnore::y() const {
  return y_;
}
inline void MapIgnore::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// -------------------------------------------------------------------

// Map

// required int32 minX = 1;
inline bool Map::has_minx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Map::set_has_minx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Map::clear_has_minx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Map::clear_minx() {
  minx_ = 0;
  clear_has_minx();
}
inline ::google::protobuf::int32 Map::minx() const {
  return minx_;
}
inline void Map::set_minx(::google::protobuf::int32 value) {
  set_has_minx();
  minx_ = value;
}

// required int32 minY = 2;
inline bool Map::has_miny() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Map::set_has_miny() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Map::clear_has_miny() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Map::clear_miny() {
  miny_ = 0;
  clear_has_miny();
}
inline ::google::protobuf::int32 Map::miny() const {
  return miny_;
}
inline void Map::set_miny(::google::protobuf::int32 value) {
  set_has_miny();
  miny_ = value;
}

// required int32 maxX = 3;
inline bool Map::has_maxx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Map::set_has_maxx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Map::clear_has_maxx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Map::clear_maxx() {
  maxx_ = 0;
  clear_has_maxx();
}
inline ::google::protobuf::int32 Map::maxx() const {
  return maxx_;
}
inline void Map::set_maxx(::google::protobuf::int32 value) {
  set_has_maxx();
  maxx_ = value;
}

// required int32 maxY = 4;
inline bool Map::has_maxy() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Map::set_has_maxy() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Map::clear_has_maxy() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Map::clear_maxy() {
  maxy_ = 0;
  clear_has_maxy();
}
inline ::google::protobuf::int32 Map::maxy() const {
  return maxy_;
}
inline void Map::set_maxy(::google::protobuf::int32 value) {
  set_has_maxy();
  maxy_ = value;
}

// -------------------------------------------------------------------

// MapUpdate

// required int32 x = 1;
inline bool MapUpdate::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapUpdate::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapUpdate::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapUpdate::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 MapUpdate::x() const {
  return x_;
}
inline void MapUpdate::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// required int32 y = 2;
inline bool MapUpdate::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapUpdate::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapUpdate::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapUpdate::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 MapUpdate::y() const {
  return y_;
}
inline void MapUpdate::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// required int32 z = 3;
inline bool MapUpdate::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MapUpdate::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MapUpdate::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MapUpdate::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline ::google::protobuf::int32 MapUpdate::z() const {
  return z_;
}
inline void MapUpdate::set_z(::google::protobuf::int32 value) {
  set_has_z();
  z_ = value;
}

// required int32 newBlock = 4;
inline bool MapUpdate::has_newblock() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MapUpdate::set_has_newblock() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MapUpdate::clear_has_newblock() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MapUpdate::clear_newblock() {
  newblock_ = 0;
  clear_has_newblock();
}
inline ::google::protobuf::int32 MapUpdate::newblock() const {
  return newblock_;
}
inline void MapUpdate::set_newblock(::google::protobuf::int32 value) {
  set_has_newblock();
  newblock_ = value;
}

// -------------------------------------------------------------------

// MapCharacterUpdate

// required int32 id = 1;
inline bool MapCharacterUpdate::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapCharacterUpdate::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapCharacterUpdate::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapCharacterUpdate::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 MapCharacterUpdate::id() const {
  return id_;
}
inline void MapCharacterUpdate::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required int32 x = 2;
inline bool MapCharacterUpdate::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapCharacterUpdate::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapCharacterUpdate::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapCharacterUpdate::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 MapCharacterUpdate::x() const {
  return x_;
}
inline void MapCharacterUpdate::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// required int32 y = 3;
inline bool MapCharacterUpdate::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MapCharacterUpdate::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MapCharacterUpdate::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MapCharacterUpdate::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 MapCharacterUpdate::y() const {
  return y_;
}
inline void MapCharacterUpdate::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// required int32 z = 4;
inline bool MapCharacterUpdate::has_z() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MapCharacterUpdate::set_has_z() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MapCharacterUpdate::clear_has_z() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MapCharacterUpdate::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline ::google::protobuf::int32 MapCharacterUpdate::z() const {
  return z_;
}
inline void MapCharacterUpdate::set_z(::google::protobuf::int32 value) {
  set_has_z();
  z_ = value;
}

// -------------------------------------------------------------------

// QueryServer

// required string parameter = 1;
inline bool QueryServer::has_parameter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryServer::set_has_parameter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryServer::clear_has_parameter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryServer::clear_parameter() {
  if (parameter_ != &::google::protobuf::internal::kEmptyString) {
    parameter_->clear();
  }
  clear_has_parameter();
}
inline const ::std::string& QueryServer::parameter() const {
  return *parameter_;
}
inline void QueryServer::set_parameter(const ::std::string& value) {
  set_has_parameter();
  if (parameter_ == &::google::protobuf::internal::kEmptyString) {
    parameter_ = new ::std::string;
  }
  parameter_->assign(value);
}
inline void QueryServer::set_parameter(const char* value) {
  set_has_parameter();
  if (parameter_ == &::google::protobuf::internal::kEmptyString) {
    parameter_ = new ::std::string;
  }
  parameter_->assign(value);
}
inline void QueryServer::set_parameter(const char* value, size_t size) {
  set_has_parameter();
  if (parameter_ == &::google::protobuf::internal::kEmptyString) {
    parameter_ = new ::std::string;
  }
  parameter_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryServer::mutable_parameter() {
  set_has_parameter();
  if (parameter_ == &::google::protobuf::internal::kEmptyString) {
    parameter_ = new ::std::string;
  }
  return parameter_;
}
inline ::std::string* QueryServer::release_parameter() {
  clear_has_parameter();
  if (parameter_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = parameter_;
    parameter_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QueryServer::set_allocated_parameter(::std::string* parameter) {
  if (parameter_ != &::google::protobuf::internal::kEmptyString) {
    delete parameter_;
  }
  if (parameter) {
    set_has_parameter();
    parameter_ = parameter;
  } else {
    clear_has_parameter();
    parameter_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// QueryServerResponse

// required string parameter = 1;
inline bool QueryServerResponse::has_parameter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryServerResponse::set_has_parameter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryServerResponse::clear_has_parameter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryServerResponse::clear_parameter() {
  if (parameter_ != &::google::protobuf::internal::kEmptyString) {
    parameter_->clear();
  }
  clear_has_parameter();
}
inline const ::std::string& QueryServerResponse::parameter() const {
  return *parameter_;
}
inline void QueryServerResponse::set_parameter(const ::std::string& value) {
  set_has_parameter();
  if (parameter_ == &::google::protobuf::internal::kEmptyString) {
    parameter_ = new ::std::string;
  }
  parameter_->assign(value);
}
inline void QueryServerResponse::set_parameter(const char* value) {
  set_has_parameter();
  if (parameter_ == &::google::protobuf::internal::kEmptyString) {
    parameter_ = new ::std::string;
  }
  parameter_->assign(value);
}
inline void QueryServerResponse::set_parameter(const char* value, size_t size) {
  set_has_parameter();
  if (parameter_ == &::google::protobuf::internal::kEmptyString) {
    parameter_ = new ::std::string;
  }
  parameter_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryServerResponse::mutable_parameter() {
  set_has_parameter();
  if (parameter_ == &::google::protobuf::internal::kEmptyString) {
    parameter_ = new ::std::string;
  }
  return parameter_;
}
inline ::std::string* QueryServerResponse::release_parameter() {
  clear_has_parameter();
  if (parameter_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = parameter_;
    parameter_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QueryServerResponse::set_allocated_parameter(::std::string* parameter) {
  if (parameter_ != &::google::protobuf::internal::kEmptyString) {
    delete parameter_;
  }
  if (parameter) {
    set_has_parameter();
    parameter_ = parameter;
  } else {
    clear_has_parameter();
    parameter_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string value = 2;
inline bool QueryServerResponse::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QueryServerResponse::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QueryServerResponse::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QueryServerResponse::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& QueryServerResponse::value() const {
  return *value_;
}
inline void QueryServerResponse::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void QueryServerResponse::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void QueryServerResponse::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryServerResponse::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* QueryServerResponse::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QueryServerResponse::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace CommsMessages

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CommsMessages::MsgType>() {
  return ::CommsMessages::MsgType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CommsMessages_2eproto__INCLUDED
