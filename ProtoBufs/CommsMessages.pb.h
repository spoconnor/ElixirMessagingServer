// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CommsMessages.proto

#ifndef PROTOBUF_CommsMessages_2eproto__INCLUDED
#define PROTOBUF_CommsMessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace CommsMessages {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CommsMessages_2eproto();
void protobuf_AssignDesc_CommsMessages_2eproto();
void protobuf_ShutdownFile_CommsMessages_2eproto();

class Message;
class Ping;
class Pong;
class Response;
class NewUser;
class Login;
class Say;
class MapRequest;
class MapIgnore;
class Map;
class MapUpdate;
class MapCharacterUpdate;
class QueryServer;
class QueryServerResponse;

enum MsgType {
  eResponse = 1,
  ePing = 2,
  ePong = 3,
  eNewUser = 4,
  eLogin = 5,
  eSay = 6,
  eMapRequest = 7,
  eMapIgnore = 8,
  eMap = 9,
  eMapUpdate = 10,
  eMapCharacterUpdate = 11,
  eQueryServer = 12,
  eQueryServerResponse = 13
};
bool MsgType_IsValid(int value);
const MsgType MsgType_MIN = eResponse;
const MsgType MsgType_MAX = eQueryServerResponse;
const int MsgType_ARRAYSIZE = MsgType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MsgType_descriptor();
inline const ::std::string& MsgType_Name(MsgType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgType_descriptor(), value);
}
inline bool MsgType_Parse(
    const ::std::string& name, MsgType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgType>(
    MsgType_descriptor(), name, value);
}
// ===================================================================

class Message : public ::google::protobuf::Message {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  void Swap(Message* other);

  // implements Message ----------------------------------------------

  Message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 msgtype = 1;
  inline bool has_msgtype() const;
  inline void clear_msgtype();
  static const int kMsgtypeFieldNumber = 1;
  inline ::google::protobuf::int32 msgtype() const;
  inline void set_msgtype(::google::protobuf::int32 value);

  // required string from = 2;
  inline bool has_from() const;
  inline void clear_from();
  static const int kFromFieldNumber = 2;
  inline const ::std::string& from() const;
  inline void set_from(const ::std::string& value);
  inline void set_from(const char* value);
  inline void set_from(const char* value, size_t size);
  inline ::std::string* mutable_from();
  inline ::std::string* release_from();
  inline void set_allocated_from(::std::string* from);

  // required string dest = 3;
  inline bool has_dest() const;
  inline void clear_dest();
  static const int kDestFieldNumber = 3;
  inline const ::std::string& dest() const;
  inline void set_dest(const ::std::string& value);
  inline void set_dest(const char* value);
  inline void set_dest(const char* value, size_t size);
  inline ::std::string* mutable_dest();
  inline ::std::string* release_dest();
  inline void set_allocated_dest(::std::string* dest);

  // optional .CommsMessages.Response response = 4;
  inline bool has_response() const;
  inline void clear_response();
  static const int kResponseFieldNumber = 4;
  inline const ::CommsMessages::Response& response() const;
  inline ::CommsMessages::Response* mutable_response();
  inline ::CommsMessages::Response* release_response();
  inline void set_allocated_response(::CommsMessages::Response* response);

  // optional .CommsMessages.Ping ping = 5;
  inline bool has_ping() const;
  inline void clear_ping();
  static const int kPingFieldNumber = 5;
  inline const ::CommsMessages::Ping& ping() const;
  inline ::CommsMessages::Ping* mutable_ping();
  inline ::CommsMessages::Ping* release_ping();
  inline void set_allocated_ping(::CommsMessages::Ping* ping);

  // optional .CommsMessages.Pong pong = 6;
  inline bool has_pong() const;
  inline void clear_pong();
  static const int kPongFieldNumber = 6;
  inline const ::CommsMessages::Pong& pong() const;
  inline ::CommsMessages::Pong* mutable_pong();
  inline ::CommsMessages::Pong* release_pong();
  inline void set_allocated_pong(::CommsMessages::Pong* pong);

  // optional .CommsMessages.NewUser newUser = 7;
  inline bool has_newuser() const;
  inline void clear_newuser();
  static const int kNewUserFieldNumber = 7;
  inline const ::CommsMessages::NewUser& newuser() const;
  inline ::CommsMessages::NewUser* mutable_newuser();
  inline ::CommsMessages::NewUser* release_newuser();
  inline void set_allocated_newuser(::CommsMessages::NewUser* newuser);

  // optional .CommsMessages.Login login = 8;
  inline bool has_login() const;
  inline void clear_login();
  static const int kLoginFieldNumber = 8;
  inline const ::CommsMessages::Login& login() const;
  inline ::CommsMessages::Login* mutable_login();
  inline ::CommsMessages::Login* release_login();
  inline void set_allocated_login(::CommsMessages::Login* login);

  // optional .CommsMessages.Say say = 9;
  inline bool has_say() const;
  inline void clear_say();
  static const int kSayFieldNumber = 9;
  inline const ::CommsMessages::Say& say() const;
  inline ::CommsMessages::Say* mutable_say();
  inline ::CommsMessages::Say* release_say();
  inline void set_allocated_say(::CommsMessages::Say* say);

  // optional .CommsMessages.MapRequest mapRequest = 10;
  inline bool has_maprequest() const;
  inline void clear_maprequest();
  static const int kMapRequestFieldNumber = 10;
  inline const ::CommsMessages::MapRequest& maprequest() const;
  inline ::CommsMessages::MapRequest* mutable_maprequest();
  inline ::CommsMessages::MapRequest* release_maprequest();
  inline void set_allocated_maprequest(::CommsMessages::MapRequest* maprequest);

  // optional .CommsMessages.MapIgnore mapIgnore = 11;
  inline bool has_mapignore() const;
  inline void clear_mapignore();
  static const int kMapIgnoreFieldNumber = 11;
  inline const ::CommsMessages::MapIgnore& mapignore() const;
  inline ::CommsMessages::MapIgnore* mutable_mapignore();
  inline ::CommsMessages::MapIgnore* release_mapignore();
  inline void set_allocated_mapignore(::CommsMessages::MapIgnore* mapignore);

  // optional .CommsMessages.Map map = 12;
  inline bool has_map() const;
  inline void clear_map();
  static const int kMapFieldNumber = 12;
  inline const ::CommsMessages::Map& map() const;
  inline ::CommsMessages::Map* mutable_map();
  inline ::CommsMessages::Map* release_map();
  inline void set_allocated_map(::CommsMessages::Map* map);

  // optional .CommsMessages.MapUpdate mapUpdate = 13;
  inline bool has_mapupdate() const;
  inline void clear_mapupdate();
  static const int kMapUpdateFieldNumber = 13;
  inline const ::CommsMessages::MapUpdate& mapupdate() const;
  inline ::CommsMessages::MapUpdate* mutable_mapupdate();
  inline ::CommsMessages::MapUpdate* release_mapupdate();
  inline void set_allocated_mapupdate(::CommsMessages::MapUpdate* mapupdate);

  // optional .CommsMessages.MapCharacterUpdate mapCharacterUpdate = 14;
  inline bool has_mapcharacterupdate() const;
  inline void clear_mapcharacterupdate();
  static const int kMapCharacterUpdateFieldNumber = 14;
  inline const ::CommsMessages::MapCharacterUpdate& mapcharacterupdate() const;
  inline ::CommsMessages::MapCharacterUpdate* mutable_mapcharacterupdate();
  inline ::CommsMessages::MapCharacterUpdate* release_mapcharacterupdate();
  inline void set_allocated_mapcharacterupdate(::CommsMessages::MapCharacterUpdate* mapcharacterupdate);

  // optional .CommsMessages.QueryServer queryServer = 15;
  inline bool has_queryserver() const;
  inline void clear_queryserver();
  static const int kQueryServerFieldNumber = 15;
  inline const ::CommsMessages::QueryServer& queryserver() const;
  inline ::CommsMessages::QueryServer* mutable_queryserver();
  inline ::CommsMessages::QueryServer* release_queryserver();
  inline void set_allocated_queryserver(::CommsMessages::QueryServer* queryserver);

  // optional .CommsMessages.QueryServerResponse queryServerResponse = 16;
  inline bool has_queryserverresponse() const;
  inline void clear_queryserverresponse();
  static const int kQueryServerResponseFieldNumber = 16;
  inline const ::CommsMessages::QueryServerResponse& queryserverresponse() const;
  inline ::CommsMessages::QueryServerResponse* mutable_queryserverresponse();
  inline ::CommsMessages::QueryServerResponse* release_queryserverresponse();
  inline void set_allocated_queryserverresponse(::CommsMessages::QueryServerResponse* queryserverresponse);

  // @@protoc_insertion_point(class_scope:CommsMessages.Message)
 private:
  inline void set_has_msgtype();
  inline void clear_has_msgtype();
  inline void set_has_from();
  inline void clear_has_from();
  inline void set_has_dest();
  inline void clear_has_dest();
  inline void set_has_response();
  inline void clear_has_response();
  inline void set_has_ping();
  inline void clear_has_ping();
  inline void set_has_pong();
  inline void clear_has_pong();
  inline void set_has_newuser();
  inline void clear_has_newuser();
  inline void set_has_login();
  inline void clear_has_login();
  inline void set_has_say();
  inline void clear_has_say();
  inline void set_has_maprequest();
  inline void clear_has_maprequest();
  inline void set_has_mapignore();
  inline void clear_has_mapignore();
  inline void set_has_map();
  inline void clear_has_map();
  inline void set_has_mapupdate();
  inline void clear_has_mapupdate();
  inline void set_has_mapcharacterupdate();
  inline void clear_has_mapcharacterupdate();
  inline void set_has_queryserver();
  inline void clear_has_queryserver();
  inline void set_has_queryserverresponse();
  inline void clear_has_queryserverresponse();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* from_;
  ::std::string* dest_;
  ::CommsMessages::Response* response_;
  ::CommsMessages::Ping* ping_;
  ::CommsMessages::Pong* pong_;
  ::CommsMessages::NewUser* newuser_;
  ::CommsMessages::Login* login_;
  ::CommsMessages::Say* say_;
  ::CommsMessages::MapRequest* maprequest_;
  ::CommsMessages::MapIgnore* mapignore_;
  ::CommsMessages::Map* map_;
  ::CommsMessages::MapUpdate* mapupdate_;
  ::CommsMessages::MapCharacterUpdate* mapcharacterupdate_;
  ::CommsMessages::QueryServer* queryserver_;
  ::CommsMessages::QueryServerResponse* queryserverresponse_;
  ::google::protobuf::int32 msgtype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];

  friend void  protobuf_AddDesc_CommsMessages_2eproto();
  friend void protobuf_AssignDesc_CommsMessages_2eproto();
  friend void protobuf_ShutdownFile_CommsMessages_2eproto();

  void InitAsDefaultInstance();
  static Message* default_instance_;
};
// -------------------------------------------------------------------

class Ping : public ::google::protobuf::Message {
 public:
  Ping();
  virtual ~Ping();

  Ping(const Ping& from);

  inline Ping& operator=(const Ping& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ping& default_instance();

  void Swap(Ping* other);

  // implements Message ----------------------------------------------

  Ping* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Ping& from);
  void MergeFrom(const Ping& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CommsMessages.Ping)
 private:
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CommsMessages_2eproto();
  friend void protobuf_AssignDesc_CommsMessages_2eproto();
  friend void protobuf_ShutdownFile_CommsMessages_2eproto();

  void InitAsDefaultInstance();
  static Ping* default_instance_;
};
// -------------------------------------------------------------------

class Pong : public ::google::protobuf::Message {
 public:
  Pong();
  virtual ~Pong();

  Pong(const Pong& from);

  inline Pong& operator=(const Pong& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pong& default_instance();

  void Swap(Pong* other);

  // implements Message ----------------------------------------------

  Pong* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Pong& from);
  void MergeFrom(const Pong& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CommsMessages.Pong)
 private:
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CommsMessages_2eproto();
  friend void protobuf_AssignDesc_CommsMessages_2eproto();
  friend void protobuf_ShutdownFile_CommsMessages_2eproto();

  void InitAsDefaultInstance();
  static Pong* default_instance_;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  void Swap(Response* other);

  // implements Message ----------------------------------------------

  Response* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // optional string message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:CommsMessages.Response)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* message_;
  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CommsMessages_2eproto();
  friend void protobuf_AssignDesc_CommsMessages_2eproto();
  friend void protobuf_ShutdownFile_CommsMessages_2eproto();

  void InitAsDefaultInstance();
  static Response* default_instance_;
};
// -------------------------------------------------------------------

class NewUser : public ::google::protobuf::Message {
 public:
  NewUser();
  virtual ~NewUser();

  NewUser(const NewUser& from);

  inline NewUser& operator=(const NewUser& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewUser& default_instance();

  void Swap(NewUser* other);

  // implements Message ----------------------------------------------

  NewUser* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NewUser& from);
  void MergeFrom(const NewUser& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // required string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // required string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:CommsMessages.NewUser)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* username_;
  ::std::string* password_;
  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CommsMessages_2eproto();
  friend void protobuf_AssignDesc_CommsMessages_2eproto();
  friend void protobuf_ShutdownFile_CommsMessages_2eproto();

  void InitAsDefaultInstance();
  static NewUser* default_instance_;
};
// -------------------------------------------------------------------

class Login : public ::google::protobuf::Message {
 public:
  Login();
  virtual ~Login();

  Login(const Login& from);

  inline Login& operator=(const Login& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Login& default_instance();

  void Swap(Login* other);

  // implements Message ----------------------------------------------

  Login* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Login& from);
  void MergeFrom(const Login& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // required string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:CommsMessages.Login)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* username_;
  ::std::string* password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CommsMessages_2eproto();
  friend void protobuf_AssignDesc_CommsMessages_2eproto();
  friend void protobuf_ShutdownFile_CommsMessages_2eproto();

  void InitAsDefaultInstance();
  static Login* default_instance_;
};
// -------------------------------------------------------------------

class Say : public ::google::protobuf::Message {
 public:
  Say();
  virtual ~Say();

  Say(const Say& from);

  inline Say& operator=(const Say& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Say& default_instance();

  void Swap(Say* other);

  // implements Message ----------------------------------------------

  Say* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Say& from);
  void MergeFrom(const Say& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string text = 1;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 1;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:CommsMessages.Say)
 private:
  inline void set_has_text();
  inline void clear_has_text();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* text_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CommsMessages_2eproto();
  friend void protobuf_AssignDesc_CommsMessages_2eproto();
  friend void protobuf_ShutdownFile_CommsMessages_2eproto();

  void InitAsDefaultInstance();
  static Say* default_instance_;
};
// -------------------------------------------------------------------

class MapRequest : public ::google::protobuf::Message {
 public:
  MapRequest();
  virtual ~MapRequest();

  MapRequest(const MapRequest& from);

  inline MapRequest& operator=(const MapRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapRequest& default_instance();

  void Swap(MapRequest* other);

  // implements Message ----------------------------------------------

  MapRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapRequest& from);
  void MergeFrom(const MapRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // required int32 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CommsMessages.MapRequest)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CommsMessages_2eproto();
  friend void protobuf_AssignDesc_CommsMessages_2eproto();
  friend void protobuf_ShutdownFile_CommsMessages_2eproto();

  void InitAsDefaultInstance();
  static MapRequest* default_instance_;
};
// -------------------------------------------------------------------

class MapIgnore : public ::google::protobuf::Message {
 public:
  MapIgnore();
  virtual ~MapIgnore();

  MapIgnore(const MapIgnore& from);

  inline MapIgnore& operator=(const MapIgnore& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapIgnore& default_instance();

  void Swap(MapIgnore* other);

  // implements Message ----------------------------------------------

  MapIgnore* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapIgnore& from);
  void MergeFrom(const MapIgnore& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // required int32 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CommsMessages.MapIgnore)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CommsMessages_2eproto();
  friend void protobuf_AssignDesc_CommsMessages_2eproto();
  friend void protobuf_ShutdownFile_CommsMessages_2eproto();

  void InitAsDefaultInstance();
  static MapIgnore* default_instance_;
};
// -------------------------------------------------------------------

class Map : public ::google::protobuf::Message {
 public:
  Map();
  virtual ~Map();

  Map(const Map& from);

  inline Map& operator=(const Map& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Map& default_instance();

  void Swap(Map* other);

  // implements Message ----------------------------------------------

  Map* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Map& from);
  void MergeFrom(const Map& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 minX = 1;
  inline bool has_minx() const;
  inline void clear_minx();
  static const int kMinXFieldNumber = 1;
  inline ::google::protobuf::int32 minx() const;
  inline void set_minx(::google::protobuf::int32 value);

  // required int32 minY = 2;
  inline bool has_miny() const;
  inline void clear_miny();
  static const int kMinYFieldNumber = 2;
  inline ::google::protobuf::int32 miny() const;
  inline void set_miny(::google::protobuf::int32 value);

  // required int32 maxX = 3;
  inline bool has_maxx() const;
  inline void clear_maxx();
  static const int kMaxXFieldNumber = 3;
  inline ::google::protobuf::int32 maxx() const;
  inline void set_maxx(::google::protobuf::int32 value);

  // required int32 maxY = 4;
  inline bool has_maxy() const;
  inline void clear_maxy();
  static const int kMaxYFieldNumber = 4;
  inline ::google::protobuf::int32 maxy() const;
  inline void set_maxy(::google::protobuf::int32 value);

  // required int32 dataSize = 5;
  inline bool has_datasize() const;
  inline void clear_datasize();
  static const int kDataSizeFieldNumber = 5;
  inline ::google::protobuf::int32 datasize() const;
  inline void set_datasize(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CommsMessages.Map)
 private:
  inline void set_has_minx();
  inline void clear_has_minx();
  inline void set_has_miny();
  inline void clear_has_miny();
  inline void set_has_maxx();
  inline void clear_has_maxx();
  inline void set_has_maxy();
  inline void clear_has_maxy();
  inline void set_has_datasize();
  inline void clear_has_datasize();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 minx_;
  ::google::protobuf::int32 miny_;
  ::google::protobuf::int32 maxx_;
  ::google::protobuf::int32 maxy_;
  ::google::protobuf::int32 datasize_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_CommsMessages_2eproto();
  friend void protobuf_AssignDesc_CommsMessages_2eproto();
  friend void protobuf_ShutdownFile_CommsMessages_2eproto();

  void InitAsDefaultInstance();
  static Map* default_instance_;
};
// -------------------------------------------------------------------

class MapUpdate : public ::google::protobuf::Message {
 public:
  MapUpdate();
  virtual ~MapUpdate();

  MapUpdate(const MapUpdate& from);

  inline MapUpdate& operator=(const MapUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapUpdate& default_instance();

  void Swap(MapUpdate* other);

  // implements Message ----------------------------------------------

  MapUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapUpdate& from);
  void MergeFrom(const MapUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // required int32 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // required int32 z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline ::google::protobuf::int32 z() const;
  inline void set_z(::google::protobuf::int32 value);

  // required int32 newBlock = 4;
  inline bool has_newblock() const;
  inline void clear_newblock();
  static const int kNewBlockFieldNumber = 4;
  inline ::google::protobuf::int32 newblock() const;
  inline void set_newblock(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CommsMessages.MapUpdate)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  inline void set_has_newblock();
  inline void clear_has_newblock();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 z_;
  ::google::protobuf::int32 newblock_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_CommsMessages_2eproto();
  friend void protobuf_AssignDesc_CommsMessages_2eproto();
  friend void protobuf_ShutdownFile_CommsMessages_2eproto();

  void InitAsDefaultInstance();
  static MapUpdate* default_instance_;
};
// -------------------------------------------------------------------

class MapCharacterUpdate : public ::google::protobuf::Message {
 public:
  MapCharacterUpdate();
  virtual ~MapCharacterUpdate();

  MapCharacterUpdate(const MapCharacterUpdate& from);

  inline MapCharacterUpdate& operator=(const MapCharacterUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapCharacterUpdate& default_instance();

  void Swap(MapCharacterUpdate* other);

  // implements Message ----------------------------------------------

  MapCharacterUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapCharacterUpdate& from);
  void MergeFrom(const MapCharacterUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required int32 x = 2;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 2;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // required int32 y = 3;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 3;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // required int32 z = 4;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 4;
  inline ::google::protobuf::int32 z() const;
  inline void set_z(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CommsMessages.MapCharacterUpdate)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 z_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_CommsMessages_2eproto();
  friend void protobuf_AssignDesc_CommsMessages_2eproto();
  friend void protobuf_ShutdownFile_CommsMessages_2eproto();

  void InitAsDefaultInstance();
  static MapCharacterUpdate* default_instance_;
};
// -------------------------------------------------------------------

class QueryServer : public ::google::protobuf::Message {
 public:
  QueryServer();
  virtual ~QueryServer();

  QueryServer(const QueryServer& from);

  inline QueryServer& operator=(const QueryServer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryServer& default_instance();

  void Swap(QueryServer* other);

  // implements Message ----------------------------------------------

  QueryServer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryServer& from);
  void MergeFrom(const QueryServer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CommsMessages.QueryServer)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_CommsMessages_2eproto();
  friend void protobuf_AssignDesc_CommsMessages_2eproto();
  friend void protobuf_ShutdownFile_CommsMessages_2eproto();

  void InitAsDefaultInstance();
  static QueryServer* default_instance_;
};
// -------------------------------------------------------------------

class QueryServerResponse : public ::google::protobuf::Message {
 public:
  QueryServerResponse();
  virtual ~QueryServerResponse();

  QueryServerResponse(const QueryServerResponse& from);

  inline QueryServerResponse& operator=(const QueryServerResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryServerResponse& default_instance();

  void Swap(QueryServerResponse* other);

  // implements Message ----------------------------------------------

  QueryServerResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryServerResponse& from);
  void MergeFrom(const QueryServerResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 minMapChunkX = 1;
  inline bool has_minmapchunkx() const;
  inline void clear_minmapchunkx();
  static const int kMinMapChunkXFieldNumber = 1;
  inline ::google::protobuf::int32 minmapchunkx() const;
  inline void set_minmapchunkx(::google::protobuf::int32 value);

  // required int32 minMapChunkY = 2;
  inline bool has_minmapchunky() const;
  inline void clear_minmapchunky();
  static const int kMinMapChunkYFieldNumber = 2;
  inline ::google::protobuf::int32 minmapchunky() const;
  inline void set_minmapchunky(::google::protobuf::int32 value);

  // required int32 maxMapChunkX = 3;
  inline bool has_maxmapchunkx() const;
  inline void clear_maxmapchunkx();
  static const int kMaxMapChunkXFieldNumber = 3;
  inline ::google::protobuf::int32 maxmapchunkx() const;
  inline void set_maxmapchunkx(::google::protobuf::int32 value);

  // required int32 maxMapChunkY = 4;
  inline bool has_maxmapchunky() const;
  inline void clear_maxmapchunky();
  static const int kMaxMapChunkYFieldNumber = 4;
  inline ::google::protobuf::int32 maxmapchunky() const;
  inline void set_maxmapchunky(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CommsMessages.QueryServerResponse)
 private:
  inline void set_has_minmapchunkx();
  inline void clear_has_minmapchunkx();
  inline void set_has_minmapchunky();
  inline void clear_has_minmapchunky();
  inline void set_has_maxmapchunkx();
  inline void clear_has_maxmapchunkx();
  inline void set_has_maxmapchunky();
  inline void clear_has_maxmapchunky();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 minmapchunkx_;
  ::google::protobuf::int32 minmapchunky_;
  ::google::protobuf::int32 maxmapchunkx_;
  ::google::protobuf::int32 maxmapchunky_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_CommsMessages_2eproto();
  friend void protobuf_AssignDesc_CommsMessages_2eproto();
  friend void protobuf_ShutdownFile_CommsMessages_2eproto();

  void InitAsDefaultInstance();
  static QueryServerResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// Message

// required int32 msgtype = 1;
inline bool Message::has_msgtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message::set_has_msgtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message::clear_has_msgtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message::clear_msgtype() {
  msgtype_ = 0;
  clear_has_msgtype();
}
inline ::google::protobuf::int32 Message::msgtype() const {
  return msgtype_;
}
inline void Message::set_msgtype(::google::protobuf::int32 value) {
  set_has_msgtype();
  msgtype_ = value;
}

// required string from = 2;
inline bool Message::has_from() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message::set_has_from() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message::clear_has_from() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message::clear_from() {
  if (from_ != &::google::protobuf::internal::kEmptyString) {
    from_->clear();
  }
  clear_has_from();
}
inline const ::std::string& Message::from() const {
  return *from_;
}
inline void Message::set_from(const ::std::string& value) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(value);
}
inline void Message::set_from(const char* value) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(value);
}
inline void Message::set_from(const char* value, size_t size) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message::mutable_from() {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  return from_;
}
inline ::std::string* Message::release_from() {
  clear_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_;
    from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Message::set_allocated_from(::std::string* from) {
  if (from_ != &::google::protobuf::internal::kEmptyString) {
    delete from_;
  }
  if (from) {
    set_has_from();
    from_ = from;
  } else {
    clear_has_from();
    from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string dest = 3;
inline bool Message::has_dest() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Message::set_has_dest() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Message::clear_has_dest() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Message::clear_dest() {
  if (dest_ != &::google::protobuf::internal::kEmptyString) {
    dest_->clear();
  }
  clear_has_dest();
}
inline const ::std::string& Message::dest() const {
  return *dest_;
}
inline void Message::set_dest(const ::std::string& value) {
  set_has_dest();
  if (dest_ == &::google::protobuf::internal::kEmptyString) {
    dest_ = new ::std::string;
  }
  dest_->assign(value);
}
inline void Message::set_dest(const char* value) {
  set_has_dest();
  if (dest_ == &::google::protobuf::internal::kEmptyString) {
    dest_ = new ::std::string;
  }
  dest_->assign(value);
}
inline void Message::set_dest(const char* value, size_t size) {
  set_has_dest();
  if (dest_ == &::google::protobuf::internal::kEmptyString) {
    dest_ = new ::std::string;
  }
  dest_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message::mutable_dest() {
  set_has_dest();
  if (dest_ == &::google::protobuf::internal::kEmptyString) {
    dest_ = new ::std::string;
  }
  return dest_;
}
inline ::std::string* Message::release_dest() {
  clear_has_dest();
  if (dest_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dest_;
    dest_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Message::set_allocated_dest(::std::string* dest) {
  if (dest_ != &::google::protobuf::internal::kEmptyString) {
    delete dest_;
  }
  if (dest) {
    set_has_dest();
    dest_ = dest;
  } else {
    clear_has_dest();
    dest_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .CommsMessages.Response response = 4;
inline bool Message::has_response() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Message::set_has_response() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Message::clear_has_response() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Message::clear_response() {
  if (response_ != NULL) response_->::CommsMessages::Response::Clear();
  clear_has_response();
}
inline const ::CommsMessages::Response& Message::response() const {
  return response_ != NULL ? *response_ : *default_instance_->response_;
}
inline ::CommsMessages::Response* Message::mutable_response() {
  set_has_response();
  if (response_ == NULL) response_ = new ::CommsMessages::Response;
  return response_;
}
inline ::CommsMessages::Response* Message::release_response() {
  clear_has_response();
  ::CommsMessages::Response* temp = response_;
  response_ = NULL;
  return temp;
}
inline void Message::set_allocated_response(::CommsMessages::Response* response) {
  delete response_;
  response_ = response;
  if (response) {
    set_has_response();
  } else {
    clear_has_response();
  }
}

// optional .CommsMessages.Ping ping = 5;
inline bool Message::has_ping() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Message::set_has_ping() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Message::clear_has_ping() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Message::clear_ping() {
  if (ping_ != NULL) ping_->::CommsMessages::Ping::Clear();
  clear_has_ping();
}
inline const ::CommsMessages::Ping& Message::ping() const {
  return ping_ != NULL ? *ping_ : *default_instance_->ping_;
}
inline ::CommsMessages::Ping* Message::mutable_ping() {
  set_has_ping();
  if (ping_ == NULL) ping_ = new ::CommsMessages::Ping;
  return ping_;
}
inline ::CommsMessages::Ping* Message::release_ping() {
  clear_has_ping();
  ::CommsMessages::Ping* temp = ping_;
  ping_ = NULL;
  return temp;
}
inline void Message::set_allocated_ping(::CommsMessages::Ping* ping) {
  delete ping_;
  ping_ = ping;
  if (ping) {
    set_has_ping();
  } else {
    clear_has_ping();
  }
}

// optional .CommsMessages.Pong pong = 6;
inline bool Message::has_pong() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Message::set_has_pong() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Message::clear_has_pong() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Message::clear_pong() {
  if (pong_ != NULL) pong_->::CommsMessages::Pong::Clear();
  clear_has_pong();
}
inline const ::CommsMessages::Pong& Message::pong() const {
  return pong_ != NULL ? *pong_ : *default_instance_->pong_;
}
inline ::CommsMessages::Pong* Message::mutable_pong() {
  set_has_pong();
  if (pong_ == NULL) pong_ = new ::CommsMessages::Pong;
  return pong_;
}
inline ::CommsMessages::Pong* Message::release_pong() {
  clear_has_pong();
  ::CommsMessages::Pong* temp = pong_;
  pong_ = NULL;
  return temp;
}
inline void Message::set_allocated_pong(::CommsMessages::Pong* pong) {
  delete pong_;
  pong_ = pong;
  if (pong) {
    set_has_pong();
  } else {
    clear_has_pong();
  }
}

// optional .CommsMessages.NewUser newUser = 7;
inline bool Message::has_newuser() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Message::set_has_newuser() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Message::clear_has_newuser() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Message::clear_newuser() {
  if (newuser_ != NULL) newuser_->::CommsMessages::NewUser::Clear();
  clear_has_newuser();
}
inline const ::CommsMessages::NewUser& Message::newuser() const {
  return newuser_ != NULL ? *newuser_ : *default_instance_->newuser_;
}
inline ::CommsMessages::NewUser* Message::mutable_newuser() {
  set_has_newuser();
  if (newuser_ == NULL) newuser_ = new ::CommsMessages::NewUser;
  return newuser_;
}
inline ::CommsMessages::NewUser* Message::release_newuser() {
  clear_has_newuser();
  ::CommsMessages::NewUser* temp = newuser_;
  newuser_ = NULL;
  return temp;
}
inline void Message::set_allocated_newuser(::CommsMessages::NewUser* newuser) {
  delete newuser_;
  newuser_ = newuser;
  if (newuser) {
    set_has_newuser();
  } else {
    clear_has_newuser();
  }
}

// optional .CommsMessages.Login login = 8;
inline bool Message::has_login() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Message::set_has_login() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Message::clear_has_login() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Message::clear_login() {
  if (login_ != NULL) login_->::CommsMessages::Login::Clear();
  clear_has_login();
}
inline const ::CommsMessages::Login& Message::login() const {
  return login_ != NULL ? *login_ : *default_instance_->login_;
}
inline ::CommsMessages::Login* Message::mutable_login() {
  set_has_login();
  if (login_ == NULL) login_ = new ::CommsMessages::Login;
  return login_;
}
inline ::CommsMessages::Login* Message::release_login() {
  clear_has_login();
  ::CommsMessages::Login* temp = login_;
  login_ = NULL;
  return temp;
}
inline void Message::set_allocated_login(::CommsMessages::Login* login) {
  delete login_;
  login_ = login;
  if (login) {
    set_has_login();
  } else {
    clear_has_login();
  }
}

// optional .CommsMessages.Say say = 9;
inline bool Message::has_say() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Message::set_has_say() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Message::clear_has_say() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Message::clear_say() {
  if (say_ != NULL) say_->::CommsMessages::Say::Clear();
  clear_has_say();
}
inline const ::CommsMessages::Say& Message::say() const {
  return say_ != NULL ? *say_ : *default_instance_->say_;
}
inline ::CommsMessages::Say* Message::mutable_say() {
  set_has_say();
  if (say_ == NULL) say_ = new ::CommsMessages::Say;
  return say_;
}
inline ::CommsMessages::Say* Message::release_say() {
  clear_has_say();
  ::CommsMessages::Say* temp = say_;
  say_ = NULL;
  return temp;
}
inline void Message::set_allocated_say(::CommsMessages::Say* say) {
  delete say_;
  say_ = say;
  if (say) {
    set_has_say();
  } else {
    clear_has_say();
  }
}

// optional .CommsMessages.MapRequest mapRequest = 10;
inline bool Message::has_maprequest() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Message::set_has_maprequest() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Message::clear_has_maprequest() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Message::clear_maprequest() {
  if (maprequest_ != NULL) maprequest_->::CommsMessages::MapRequest::Clear();
  clear_has_maprequest();
}
inline const ::CommsMessages::MapRequest& Message::maprequest() const {
  return maprequest_ != NULL ? *maprequest_ : *default_instance_->maprequest_;
}
inline ::CommsMessages::MapRequest* Message::mutable_maprequest() {
  set_has_maprequest();
  if (maprequest_ == NULL) maprequest_ = new ::CommsMessages::MapRequest;
  return maprequest_;
}
inline ::CommsMessages::MapRequest* Message::release_maprequest() {
  clear_has_maprequest();
  ::CommsMessages::MapRequest* temp = maprequest_;
  maprequest_ = NULL;
  return temp;
}
inline void Message::set_allocated_maprequest(::CommsMessages::MapRequest* maprequest) {
  delete maprequest_;
  maprequest_ = maprequest;
  if (maprequest) {
    set_has_maprequest();
  } else {
    clear_has_maprequest();
  }
}

// optional .CommsMessages.MapIgnore mapIgnore = 11;
inline bool Message::has_mapignore() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Message::set_has_mapignore() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Message::clear_has_mapignore() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Message::clear_mapignore() {
  if (mapignore_ != NULL) mapignore_->::CommsMessages::MapIgnore::Clear();
  clear_has_mapignore();
}
inline const ::CommsMessages::MapIgnore& Message::mapignore() const {
  return mapignore_ != NULL ? *mapignore_ : *default_instance_->mapignore_;
}
inline ::CommsMessages::MapIgnore* Message::mutable_mapignore() {
  set_has_mapignore();
  if (mapignore_ == NULL) mapignore_ = new ::CommsMessages::MapIgnore;
  return mapignore_;
}
inline ::CommsMessages::MapIgnore* Message::release_mapignore() {
  clear_has_mapignore();
  ::CommsMessages::MapIgnore* temp = mapignore_;
  mapignore_ = NULL;
  return temp;
}
inline void Message::set_allocated_mapignore(::CommsMessages::MapIgnore* mapignore) {
  delete mapignore_;
  mapignore_ = mapignore;
  if (mapignore) {
    set_has_mapignore();
  } else {
    clear_has_mapignore();
  }
}

// optional .CommsMessages.Map map = 12;
inline bool Message::has_map() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Message::set_has_map() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Message::clear_has_map() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Message::clear_map() {
  if (map_ != NULL) map_->::CommsMessages::Map::Clear();
  clear_has_map();
}
inline const ::CommsMessages::Map& Message::map() const {
  return map_ != NULL ? *map_ : *default_instance_->map_;
}
inline ::CommsMessages::Map* Message::mutable_map() {
  set_has_map();
  if (map_ == NULL) map_ = new ::CommsMessages::Map;
  return map_;
}
inline ::CommsMessages::Map* Message::release_map() {
  clear_has_map();
  ::CommsMessages::Map* temp = map_;
  map_ = NULL;
  return temp;
}
inline void Message::set_allocated_map(::CommsMessages::Map* map) {
  delete map_;
  map_ = map;
  if (map) {
    set_has_map();
  } else {
    clear_has_map();
  }
}

// optional .CommsMessages.MapUpdate mapUpdate = 13;
inline bool Message::has_mapupdate() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Message::set_has_mapupdate() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Message::clear_has_mapupdate() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Message::clear_mapupdate() {
  if (mapupdate_ != NULL) mapupdate_->::CommsMessages::MapUpdate::Clear();
  clear_has_mapupdate();
}
inline const ::CommsMessages::MapUpdate& Message::mapupdate() const {
  return mapupdate_ != NULL ? *mapupdate_ : *default_instance_->mapupdate_;
}
inline ::CommsMessages::MapUpdate* Message::mutable_mapupdate() {
  set_has_mapupdate();
  if (mapupdate_ == NULL) mapupdate_ = new ::CommsMessages::MapUpdate;
  return mapupdate_;
}
inline ::CommsMessages::MapUpdate* Message::release_mapupdate() {
  clear_has_mapupdate();
  ::CommsMessages::MapUpdate* temp = mapupdate_;
  mapupdate_ = NULL;
  return temp;
}
inline void Message::set_allocated_mapupdate(::CommsMessages::MapUpdate* mapupdate) {
  delete mapupdate_;
  mapupdate_ = mapupdate;
  if (mapupdate) {
    set_has_mapupdate();
  } else {
    clear_has_mapupdate();
  }
}

// optional .CommsMessages.MapCharacterUpdate mapCharacterUpdate = 14;
inline bool Message::has_mapcharacterupdate() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Message::set_has_mapcharacterupdate() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Message::clear_has_mapcharacterupdate() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Message::clear_mapcharacterupdate() {
  if (mapcharacterupdate_ != NULL) mapcharacterupdate_->::CommsMessages::MapCharacterUpdate::Clear();
  clear_has_mapcharacterupdate();
}
inline const ::CommsMessages::MapCharacterUpdate& Message::mapcharacterupdate() const {
  return mapcharacterupdate_ != NULL ? *mapcharacterupdate_ : *default_instance_->mapcharacterupdate_;
}
inline ::CommsMessages::MapCharacterUpdate* Message::mutable_mapcharacterupdate() {
  set_has_mapcharacterupdate();
  if (mapcharacterupdate_ == NULL) mapcharacterupdate_ = new ::CommsMessages::MapCharacterUpdate;
  return mapcharacterupdate_;
}
inline ::CommsMessages::MapCharacterUpdate* Message::release_mapcharacterupdate() {
  clear_has_mapcharacterupdate();
  ::CommsMessages::MapCharacterUpdate* temp = mapcharacterupdate_;
  mapcharacterupdate_ = NULL;
  return temp;
}
inline void Message::set_allocated_mapcharacterupdate(::CommsMessages::MapCharacterUpdate* mapcharacterupdate) {
  delete mapcharacterupdate_;
  mapcharacterupdate_ = mapcharacterupdate;
  if (mapcharacterupdate) {
    set_has_mapcharacterupdate();
  } else {
    clear_has_mapcharacterupdate();
  }
}

// optional .CommsMessages.QueryServer queryServer = 15;
inline bool Message::has_queryserver() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Message::set_has_queryserver() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Message::clear_has_queryserver() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Message::clear_queryserver() {
  if (queryserver_ != NULL) queryserver_->::CommsMessages::QueryServer::Clear();
  clear_has_queryserver();
}
inline const ::CommsMessages::QueryServer& Message::queryserver() const {
  return queryserver_ != NULL ? *queryserver_ : *default_instance_->queryserver_;
}
inline ::CommsMessages::QueryServer* Message::mutable_queryserver() {
  set_has_queryserver();
  if (queryserver_ == NULL) queryserver_ = new ::CommsMessages::QueryServer;
  return queryserver_;
}
inline ::CommsMessages::QueryServer* Message::release_queryserver() {
  clear_has_queryserver();
  ::CommsMessages::QueryServer* temp = queryserver_;
  queryserver_ = NULL;
  return temp;
}
inline void Message::set_allocated_queryserver(::CommsMessages::QueryServer* queryserver) {
  delete queryserver_;
  queryserver_ = queryserver;
  if (queryserver) {
    set_has_queryserver();
  } else {
    clear_has_queryserver();
  }
}

// optional .CommsMessages.QueryServerResponse queryServerResponse = 16;
inline bool Message::has_queryserverresponse() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Message::set_has_queryserverresponse() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Message::clear_has_queryserverresponse() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Message::clear_queryserverresponse() {
  if (queryserverresponse_ != NULL) queryserverresponse_->::CommsMessages::QueryServerResponse::Clear();
  clear_has_queryserverresponse();
}
inline const ::CommsMessages::QueryServerResponse& Message::queryserverresponse() const {
  return queryserverresponse_ != NULL ? *queryserverresponse_ : *default_instance_->queryserverresponse_;
}
inline ::CommsMessages::QueryServerResponse* Message::mutable_queryserverresponse() {
  set_has_queryserverresponse();
  if (queryserverresponse_ == NULL) queryserverresponse_ = new ::CommsMessages::QueryServerResponse;
  return queryserverresponse_;
}
inline ::CommsMessages::QueryServerResponse* Message::release_queryserverresponse() {
  clear_has_queryserverresponse();
  ::CommsMessages::QueryServerResponse* temp = queryserverresponse_;
  queryserverresponse_ = NULL;
  return temp;
}
inline void Message::set_allocated_queryserverresponse(::CommsMessages::QueryServerResponse* queryserverresponse) {
  delete queryserverresponse_;
  queryserverresponse_ = queryserverresponse;
  if (queryserverresponse) {
    set_has_queryserverresponse();
  } else {
    clear_has_queryserverresponse();
  }
}

// -------------------------------------------------------------------

// Ping

// required int32 count = 1;
inline bool Ping::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ping::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ping::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ping::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 Ping::count() const {
  return count_;
}
inline void Ping::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// Pong

// required int32 count = 1;
inline bool Pong::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Pong::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Pong::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Pong::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 Pong::count() const {
  return count_;
}
inline void Pong::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// Response

// required int32 code = 1;
inline bool Response::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 Response::code() const {
  return code_;
}
inline void Response::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// optional string message = 2;
inline bool Response::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& Response::message() const {
  return *message_;
}
inline void Response::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void Response::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void Response::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Response::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* Response::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Response::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// NewUser

// required string username = 1;
inline bool NewUser::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewUser::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewUser::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewUser::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& NewUser::username() const {
  return *username_;
}
inline void NewUser::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void NewUser::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void NewUser::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NewUser::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* NewUser::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NewUser::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string password = 2;
inline bool NewUser::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewUser::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewUser::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewUser::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& NewUser::password() const {
  return *password_;
}
inline void NewUser::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void NewUser::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void NewUser::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NewUser::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* NewUser::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NewUser::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string name = 3;
inline bool NewUser::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NewUser::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NewUser::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NewUser::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& NewUser::name() const {
  return *name_;
}
inline void NewUser::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NewUser::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NewUser::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NewUser::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* NewUser::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NewUser::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Login

// required string username = 1;
inline bool Login::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Login::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Login::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Login::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& Login::username() const {
  return *username_;
}
inline void Login::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void Login::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void Login::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Login::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* Login::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Login::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string password = 2;
inline bool Login::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Login::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Login::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Login::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& Login::password() const {
  return *password_;
}
inline void Login::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void Login::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void Login::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Login::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* Login::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Login::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Say

// required string text = 1;
inline bool Say::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Say::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Say::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Say::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& Say::text() const {
  return *text_;
}
inline void Say::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void Say::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void Say::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Say::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* Say::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Say::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MapRequest

// required int32 x = 1;
inline bool MapRequest::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapRequest::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapRequest::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapRequest::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 MapRequest::x() const {
  return x_;
}
inline void MapRequest::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// required int32 y = 2;
inline bool MapRequest::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapRequest::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapRequest::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapRequest::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 MapRequest::y() const {
  return y_;
}
inline void MapRequest::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// -------------------------------------------------------------------

// MapIgnore

// required int32 x = 1;
inline bool MapIgnore::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapIgnore::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapIgnore::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapIgnore::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 MapIgnore::x() const {
  return x_;
}
inline void MapIgnore::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// required int32 y = 2;
inline bool MapIgnore::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapIgnore::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapIgnore::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapIgnore::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 MapIgnore::y() const {
  return y_;
}
inline void MapIgnore::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// -------------------------------------------------------------------

// Map

// required int32 minX = 1;
inline bool Map::has_minx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Map::set_has_minx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Map::clear_has_minx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Map::clear_minx() {
  minx_ = 0;
  clear_has_minx();
}
inline ::google::protobuf::int32 Map::minx() const {
  return minx_;
}
inline void Map::set_minx(::google::protobuf::int32 value) {
  set_has_minx();
  minx_ = value;
}

// required int32 minY = 2;
inline bool Map::has_miny() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Map::set_has_miny() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Map::clear_has_miny() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Map::clear_miny() {
  miny_ = 0;
  clear_has_miny();
}
inline ::google::protobuf::int32 Map::miny() const {
  return miny_;
}
inline void Map::set_miny(::google::protobuf::int32 value) {
  set_has_miny();
  miny_ = value;
}

// required int32 maxX = 3;
inline bool Map::has_maxx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Map::set_has_maxx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Map::clear_has_maxx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Map::clear_maxx() {
  maxx_ = 0;
  clear_has_maxx();
}
inline ::google::protobuf::int32 Map::maxx() const {
  return maxx_;
}
inline void Map::set_maxx(::google::protobuf::int32 value) {
  set_has_maxx();
  maxx_ = value;
}

// required int32 maxY = 4;
inline bool Map::has_maxy() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Map::set_has_maxy() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Map::clear_has_maxy() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Map::clear_maxy() {
  maxy_ = 0;
  clear_has_maxy();
}
inline ::google::protobuf::int32 Map::maxy() const {
  return maxy_;
}
inline void Map::set_maxy(::google::protobuf::int32 value) {
  set_has_maxy();
  maxy_ = value;
}

// required int32 dataSize = 5;
inline bool Map::has_datasize() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Map::set_has_datasize() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Map::clear_has_datasize() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Map::clear_datasize() {
  datasize_ = 0;
  clear_has_datasize();
}
inline ::google::protobuf::int32 Map::datasize() const {
  return datasize_;
}
inline void Map::set_datasize(::google::protobuf::int32 value) {
  set_has_datasize();
  datasize_ = value;
}

// -------------------------------------------------------------------

// MapUpdate

// required int32 x = 1;
inline bool MapUpdate::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapUpdate::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapUpdate::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapUpdate::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 MapUpdate::x() const {
  return x_;
}
inline void MapUpdate::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// required int32 y = 2;
inline bool MapUpdate::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapUpdate::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapUpdate::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapUpdate::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 MapUpdate::y() const {
  return y_;
}
inline void MapUpdate::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// required int32 z = 3;
inline bool MapUpdate::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MapUpdate::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MapUpdate::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MapUpdate::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline ::google::protobuf::int32 MapUpdate::z() const {
  return z_;
}
inline void MapUpdate::set_z(::google::protobuf::int32 value) {
  set_has_z();
  z_ = value;
}

// required int32 newBlock = 4;
inline bool MapUpdate::has_newblock() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MapUpdate::set_has_newblock() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MapUpdate::clear_has_newblock() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MapUpdate::clear_newblock() {
  newblock_ = 0;
  clear_has_newblock();
}
inline ::google::protobuf::int32 MapUpdate::newblock() const {
  return newblock_;
}
inline void MapUpdate::set_newblock(::google::protobuf::int32 value) {
  set_has_newblock();
  newblock_ = value;
}

// -------------------------------------------------------------------

// MapCharacterUpdate

// required int32 id = 1;
inline bool MapCharacterUpdate::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapCharacterUpdate::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapCharacterUpdate::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapCharacterUpdate::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 MapCharacterUpdate::id() const {
  return id_;
}
inline void MapCharacterUpdate::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required int32 x = 2;
inline bool MapCharacterUpdate::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapCharacterUpdate::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapCharacterUpdate::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapCharacterUpdate::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 MapCharacterUpdate::x() const {
  return x_;
}
inline void MapCharacterUpdate::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// required int32 y = 3;
inline bool MapCharacterUpdate::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MapCharacterUpdate::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MapCharacterUpdate::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MapCharacterUpdate::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 MapCharacterUpdate::y() const {
  return y_;
}
inline void MapCharacterUpdate::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// required int32 z = 4;
inline bool MapCharacterUpdate::has_z() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MapCharacterUpdate::set_has_z() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MapCharacterUpdate::clear_has_z() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MapCharacterUpdate::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline ::google::protobuf::int32 MapCharacterUpdate::z() const {
  return z_;
}
inline void MapCharacterUpdate::set_z(::google::protobuf::int32 value) {
  set_has_z();
  z_ = value;
}

// -------------------------------------------------------------------

// QueryServer

// -------------------------------------------------------------------

// QueryServerResponse

// required int32 minMapChunkX = 1;
inline bool QueryServerResponse::has_minmapchunkx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryServerResponse::set_has_minmapchunkx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryServerResponse::clear_has_minmapchunkx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryServerResponse::clear_minmapchunkx() {
  minmapchunkx_ = 0;
  clear_has_minmapchunkx();
}
inline ::google::protobuf::int32 QueryServerResponse::minmapchunkx() const {
  return minmapchunkx_;
}
inline void QueryServerResponse::set_minmapchunkx(::google::protobuf::int32 value) {
  set_has_minmapchunkx();
  minmapchunkx_ = value;
}

// required int32 minMapChunkY = 2;
inline bool QueryServerResponse::has_minmapchunky() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QueryServerResponse::set_has_minmapchunky() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QueryServerResponse::clear_has_minmapchunky() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QueryServerResponse::clear_minmapchunky() {
  minmapchunky_ = 0;
  clear_has_minmapchunky();
}
inline ::google::protobuf::int32 QueryServerResponse::minmapchunky() const {
  return minmapchunky_;
}
inline void QueryServerResponse::set_minmapchunky(::google::protobuf::int32 value) {
  set_has_minmapchunky();
  minmapchunky_ = value;
}

// required int32 maxMapChunkX = 3;
inline bool QueryServerResponse::has_maxmapchunkx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QueryServerResponse::set_has_maxmapchunkx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QueryServerResponse::clear_has_maxmapchunkx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QueryServerResponse::clear_maxmapchunkx() {
  maxmapchunkx_ = 0;
  clear_has_maxmapchunkx();
}
inline ::google::protobuf::int32 QueryServerResponse::maxmapchunkx() const {
  return maxmapchunkx_;
}
inline void QueryServerResponse::set_maxmapchunkx(::google::protobuf::int32 value) {
  set_has_maxmapchunkx();
  maxmapchunkx_ = value;
}

// required int32 maxMapChunkY = 4;
inline bool QueryServerResponse::has_maxmapchunky() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void QueryServerResponse::set_has_maxmapchunky() {
  _has_bits_[0] |= 0x00000008u;
}
inline void QueryServerResponse::clear_has_maxmapchunky() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void QueryServerResponse::clear_maxmapchunky() {
  maxmapchunky_ = 0;
  clear_has_maxmapchunky();
}
inline ::google::protobuf::int32 QueryServerResponse::maxmapchunky() const {
  return maxmapchunky_;
}
inline void QueryServerResponse::set_maxmapchunky(::google::protobuf::int32 value) {
  set_has_maxmapchunky();
  maxmapchunky_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace CommsMessages

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CommsMessages::MsgType>() {
  return ::CommsMessages::MsgType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CommsMessages_2eproto__INCLUDED
